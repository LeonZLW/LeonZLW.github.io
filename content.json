{"meta":{"title":"Leon’s Blog","subtitle":"Dreams don't work unless you do.","description":"iOS Developer","author":"Leon","url":"http://leonzlw.github.io","root":"/"},"pages":[{"title":"分类","date":"2023-06-25T07:58:25.000Z","updated":"2023-06-25T08:24:18.078Z","comments":true,"path":"categories/index.html","permalink":"http://leonzlw.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-06-25T08:27:01.000Z","updated":"2023-06-25T08:27:46.366Z","comments":true,"path":"tags/index.html","permalink":"http://leonzlw.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"GitLab部署","slug":"CI:CD","date":"2023-06-25T10:03:07.000Z","updated":"2023-06-25T08:19:41.418Z","comments":true,"path":"2023/06/25/CI:CD/","link":"","permalink":"http://leonzlw.github.io/2023/06/25/CI:CD/","excerpt":"啥也没有呢","text":"啥也没有呢","categories":[{"name":"分类测试","slug":"分类测试","permalink":"http://leonzlw.github.io/categories/分类测试/"},{"name":"分类测试2","slug":"分类测试/分类测试2","permalink":"http://leonzlw.github.io/categories/分类测试/分类测试2/"}],"tags":[{"name":"出发222","slug":"出发222","permalink":"http://leonzlw.github.io/tags/出发222/"}]},{"title":"Hexo回归采坑记录","slug":"gitlab","date":"2023-06-25T10:03:07.000Z","updated":"2023-06-25T07:51:24.941Z","comments":true,"path":"2023/06/25/gitlab/","link":"","permalink":"http://leonzlw.github.io/2023/06/25/gitlab/","excerpt":"好久没更新博客了，趁着端午节空闲下来","text":"好久没更新博客了，趁着端午节空闲下来","categories":[],"tags":[{"name":"再出发","slug":"再出发","permalink":"http://leonzlw.github.io/tags/再出发/"}]},{"title":"TableView优化(图片加载)","slug":"optimizeTableImageView","date":"2016-08-10T08:14:26.000Z","updated":"2023-06-25T09:49:53.451Z","comments":true,"path":"2016/08/10/optimizeTableImageView/","link":"","permalink":"http://leonzlw.github.io/2016/08/10/optimizeTableImageView/","excerpt":"TableView是我们开发过程中使用最频繁的UI控件之一,苹果已经为它做了很多优化(比如:cell重用池),再加上如今手机设备各方面性能的提升,让开发不需要为性能过多考虑就可以实现比较流畅的页面效果,但是同样的效果在老机型上不见得可以运行的很流畅。当下的应用中产生操作不流畅的原因往往是许多因素集合在一起导致的,比如:资源占用量过大,离屏渲染,视图层级过多,业务不正当处理阻塞主线程等等…,所以我们要从每一点抓起方可提升应用性能最大化,本篇文章将主要针对tableView上的图片加载来做优化处理。 图片加载过程首先要了解一下加载图片的过程: 通过图片url下载图片 写入磁盘 从磁盘读取数据到内核缓冲区 从内核缓冲区复制到用户空间 解压缩成位图(非常耗cpu资源) 将解压缩的位图传给UIImageView UIImageView传给CoreAnimation,然后提交给渲染服务 渲染完成提交到帧缓冲区 屏幕显示器从帧缓冲区逐行读取显示出来","text":"TableView是我们开发过程中使用最频繁的UI控件之一,苹果已经为它做了很多优化(比如:cell重用池),再加上如今手机设备各方面性能的提升,让开发不需要为性能过多考虑就可以实现比较流畅的页面效果,但是同样的效果在老机型上不见得可以运行的很流畅。当下的应用中产生操作不流畅的原因往往是许多因素集合在一起导致的,比如:资源占用量过大,离屏渲染,视图层级过多,业务不正当处理阻塞主线程等等…,所以我们要从每一点抓起方可提升应用性能最大化,本篇文章将主要针对tableView上的图片加载来做优化处理。 图片加载过程首先要了解一下加载图片的过程: 通过图片url下载图片 写入磁盘 从磁盘读取数据到内核缓冲区 从内核缓冲区复制到用户空间 解压缩成位图(非常耗cpu资源) 将解压缩的位图传给UIImageView UIImageView传给CoreAnimation,然后提交给渲染服务 渲染完成提交到帧缓冲区 屏幕显示器从帧缓冲区逐行读取显示出来 当我们滑动tableView图片列表时,每一个cell上的UIImageView都会进行上面的1-9步的过程,而出现性能问题的原因主要发生在第5步(在不考虑离屏渲染情况下,比如给UIImageView设置圆角,阴影等..),所以要想办法把解压缩的过程放到子线程去做,解压缩后的图片给缓存起来以供后续需要的时候使用,SDWebImage库就是这么去做的: 通过图片url异步下载图片 将图片异步解压缩 将解压缩的图片传给UIImageView,并把url转化为存储Key将解压缩的图片缓存起来 同一个url请求时,直接将缓存的解压缩图片取出来供UIImageView使用 下面是SDWebImage把图片解压缩成可以直接渲染的UIImage的源码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576+ (UIImage *)decodedImageWithImage:(UIImage *)image &#123; // while downloading huge amount of images // autorelease the bitmap context // and all vars to help system to free memory // when there are memory warning. // on iOS7, do not forget to call // [[SDImageCache sharedImageCache] clearMemory]; if (image == nil) &#123; // Prevent &quot;CGBitmapContextCreateImage: invalid context 0x0&quot; error return nil; &#125; @autoreleasepool&#123; // do not decode animated images if (image.images != nil) &#123; return image; &#125; CGImageRef imageRef = image.CGImage; CGImageAlphaInfo alpha = CGImageGetAlphaInfo(imageRef); BOOL anyAlpha = (alpha == kCGImageAlphaFirst || alpha == kCGImageAlphaLast || alpha == kCGImageAlphaPremultipliedFirst || alpha == kCGImageAlphaPremultipliedLast); if (anyAlpha) &#123; return image; &#125; // current CGColorSpaceModel imageColorSpaceModel = CGColorSpaceGetModel(CGImageGetColorSpace(imageRef)); CGColorSpaceRef colorspaceRef = CGImageGetColorSpace(imageRef); BOOL unsupportedColorSpace = (imageColorSpaceModel == kCGColorSpaceModelUnknown || imageColorSpaceModel == kCGColorSpaceModelMonochrome || imageColorSpaceModel == kCGColorSpaceModelCMYK || imageColorSpaceModel == kCGColorSpaceModelIndexed); if (unsupportedColorSpace) &#123; colorspaceRef = CGColorSpaceCreateDeviceRGB(); &#125; size_t width = CGImageGetWidth(imageRef); size_t height = CGImageGetHeight(imageRef); NSUInteger bytesPerPixel = 4; NSUInteger bytesPerRow = bytesPerPixel * width; NSUInteger bitsPerComponent = 8; // kCGImageAlphaNone is not supported in CGBitmapContextCreate. // Since the original image here has no alpha info, use kCGImageAlphaNoneSkipLast // to create bitmap graphics contexts without alpha info. CGContextRef context = CGBitmapContextCreate(NULL, width, height, bitsPerComponent, bytesPerRow, colorspaceRef, kCGBitmapByteOrderDefault|kCGImageAlphaNoneSkipLast); // Draw the image into the context and retrieve the new bitmap image without alpha CGContextDrawImage(context, CGRectMake(0, 0, width, height), imageRef); CGImageRef imageRefWithoutAlpha = CGBitmapContextCreateImage(context); UIImage *imageWithoutAlpha = [UIImage imageWithCGImage:imageRefWithoutAlpha scale:image.scale orientation:image.imageOrientation]; if (unsupportedColorSpace) &#123; CGColorSpaceRelease(colorspaceRef); &#125; CGContextRelease(context); CGImageRelease(imageRefWithoutAlpha); return imageWithoutAlpha; &#125;&#125; 使用SDWebImage库就可以帮助我们优化加载图片的过程了,可是这样还不够,在浏览商品列表时我们经常会快速滚动屏幕直到找到心仪的商品才会停下来看,但是在这一过程中其他的商品图片也被加载出来了,这就造成了网络资源的浪费和用户流浪的浪费,在这个网络飞速发展的时代,一眨眼一闭眼几M甚至几十M流量就跑光了,别说用户不敢用,自己用都害怕- -。 优化加载逻辑既然要把控住网络开销和用户流量流失就要针对用户的操作来优化加载逻辑,最终的效果希望是这个样子: 当用户拖拽视图列表时会加载cell中的图片 当用户快速滑动减速过程中cell只加载已缓存过的图片,未缓存的图片不加载(减少网络开销和图片加载开销) 如果当前屏幕滚动出来的cell是属于目标区域(targetContentOffset)的cell就正常加载 显示图片添加渐变过渡效果 想要实现上面的效果,就要知道tableView什么时候发生了拖拽操作,什么时候在减速运动,然而这里要注意一下:UITableView为我们提供了dragging和decelerating属性,这两个属性并不能用来判断tableView是在被拖动还是减速过程,因为当我们连续拖拽tableView列表,这一过程dragging和decelerating的变化是这样的: 刚刚拖拽时:dragging=YES,decelerating=NO 拖拽完毕的减速过程:dragging=YES,decelerating=YES 减速还未完全停止时再次拖拽:dragging=YES,decelerating=YES 通过阅读这篇文章学习到了另一种方式来替代,下面是他的核心代码,我做了一些注释去更好地理解: 123456789101112131415161718192021- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView&#123; self.targetRect = nil; // 1.用户开始拖拽的时候去加载已显示在屏幕上的cell,如果不调用这个方法的话,当快速滑动图片列表在减速过程尚未完全停止的情况下又对它进行拖动操作,这时候当前屏幕上未加载出来图片的cell拖动的时候就不会重新加载图片了,因为这个cell已经在屏幕上了,不会再走cellForRowAtIndexPath方法 [self loadImageForVisibleCells];&#125;- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset&#123; // 2.targetRect用来记录减速到最后会停留的区域 CGRect targetRect = CGRectMake(targetContentOffset-&gt;x, targetContentOffset-&gt;y, scrollView.frame.size.width, scrollView.frame.size.height); self.targetRect = [NSValue valueWithCGRect:targetRect];&#125;- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView&#123; self.targetRect = nil; 3. 最终减速到静止状态,再次对已显示在屏幕上的cell加载图片 [self loadImageForVisibleCells];&#125; 是否加载图片的逻辑: 123456789101112131415BOOL shouldLoadImage = YES; // self.targetRect是用来判断是否在减速过程当中// !CGRectIntersectsRect([self.targetRect CGRectValue], cellFrame)是用来判断出现的cell是否在目标区域// 4.这两个判断合起来的意思是:tableView正处于减速过程,显示的cell也不在目标区域才为真if (self.targetRect &amp;&amp; !CGRectIntersectsRect([self.targetRect CGRectValue], cellFrame)) &#123; SDImageCache *cache = [manager imageCache]; NSString *key = [manager cacheKeyForURL:targetURL]; // 判断是否有该图片的缓存 if (![cache imageFromMemoryCacheForKey:key]) &#123; shouldLoadImage = NO; &#125;&#125;if (shouldLoadImage) &#123; // load image&#125; 代码注释1中的[self loadImageForVisibleCells]不去调用的话看一下效果: 代码注释4中的条件判断!CGRectIntersectsRect([self.targetRect CGRectValue], cellFrame)就是用来实现减速过程中,cell在目标区域的直接load image,不在目标区域的判断是否有图片缓存(减速过程中对有缓存的图片也加载),如果去掉这个判断的话,只有当减速完全停止的情况下才会去加载,来感受一下去掉后的效果: 我在项目中的使用在图片加载方面优化完tableView加载逻辑再配合SDWebImage使用就能达到一个比较不错的效果。由于项目中大多数页面都需要加载图片,所以不可能在每一个页面都去写重复的优化代码,因此我把这部分的优化进行了封装。 创建UIViewController Category 首先要通过scrollViewWillBeginDragging,scrollViewWillEndDragging:withVelocity:targetContentOffset:,scrollViewDidEndDecelerating协议方法来捕捉tableView的运动状态,但是又不想写在每一个控制器页面,因此我创建了一个UIViewController的分类UIViewController+LEOCellTargetRect来实现这些协议方法,只要你在需要优化页面的控制器实现了UITableViewDelegate(UIScrollViewDelegate)协议,当tableView被操作的时候就会调用分类中的协议方法。 然后通过关联对象的方式来为分类添加targetRect属性和把block关联到对象上 UIViewController+LEOCellTargetRect分类的实现代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@implementation UIViewController (LEOCellTargetRect)- (NSValue *)targetRect &#123; return objc_getAssociatedObject(self, &amp;LEO_TARGETRECT_KEY);&#125;- (void)setTargetRect:(NSValue *)targetRect &#123; objc_setAssociatedObject(self, &amp;LEO_TARGETRECT_KEY, targetRect, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;- (void)lvh_loadVisibleCellHandle:(LEOLoadVisibleCellHandler)handler &#123; objc_setAssociatedObject(self, &amp;LEO_VISIBLECELLBLOCK_KEY, handler, OBJC_ASSOCIATION_COPY_NONATOMIC);&#125;- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView &#123; self.targetRect = nil; // 1.用户开始拖拽的时候去加载已显示在屏幕上的cell,如果不调用这个方法的话,当快速滑动图片列表在减速过程尚未完全停止的情况下又对它进行拖动操作,这时候当前屏幕上未加载出来图片的cell拖动的时候就不会重新加载图片了,因为这个cell已经在屏幕上了,不会再走cellForRowAtIndexPath方法 [self p_loadVisibleCellInScrollView:scrollView];&#125;- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset &#123; // 2.targetRect用来记录减速到最后会停留的区域 CGRect targetRect = CGRectMake(targetContentOffset-&gt;x, targetContentOffset-&gt;y, scrollView.bounds.size.width, scrollView.bounds.size.height); self.targetRect = [NSValue valueWithCGRect:targetRect]; &#125;- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView &#123; self.targetRect = nil; // 3. 最终减速到静止状态,再次对已显示在屏幕上的cell加载图片 [self p_loadVisibleCellInScrollView:scrollView];&#125;- (void)p_loadVisibleCellInScrollView:(UIScrollView *)scrollView &#123; LEOLoadVisibleCellHandler block = objc_getAssociatedObject(self, &amp;LEO_VISIBLECELLBLOCK_KEY); block(scrollView); if (block) &#123; block(scrollView); &#125;&#125;@end 在需要优化的页面这样使用: 123456789101112131415__weak typeof(self) weakSelf = self;[self lvh_loadVisibleCellHandle:^(UITableView *tableView) &#123; // 由于每一个页面的数据都不相同,所以数据方面的处理放在block中进行 // 获取可见的cell数组,然后便利数组,对每一个可见的cell进行图片加载操作 NSArray *visibleCells = [tableView visibleCells]; for (LEOImageCell *cell in visibleCells) &#123; NSIndexPath *indexPath = [tableView indexPathForCell:cell]; NSDictionary *itemDic = weakSelf.imageSource[indexPath.row]; // 获取cell在tableView中的位置 CGRect cellFrame = [weakSelf.showImageTableView rectForRowAtIndexPath:indexPath]; // 把需要的参数传入到cell方法中对UIImageView进行操作(内部实现借助下面提到的UIImageView去做) [cell loadVisibleWithItem:itemDic targetRect:weakSelf.targetRect cellFrame:cellFrame]; &#125; &#125;]; UIImageView Category 最终不管是哪个cell,都要通过UIImageView来进行加载图片,所以我们可以通过创建一个UIImageView的分类来处理加载逻辑,再创建一个UIImageView的分类来做动画过渡效果: 1.UIImageView+LEOVisibleImageViewOfCell处理加载逻辑的实现代码: 1234567891011121314151617181920212223242526272829303132333435363738@implementation UIImageView (LEOVisibleImageViewOfCell)- (void)lvc_loadVisibleImageWithURL:(NSURL *)imageURL targetRect:(NSValue *)aTargetRect cellFrame:(CGRect)aCellFrame &#123; // 先判断当前imageView上的图片url 是否与当前要显示的url一致 如果一致的话就不走括号里的处理逻辑 使用当前的图片 if (![[self sd_imageURL] isEqual:imageURL]) &#123; BOOL shouldLoadImage = YES; SDWebImageManager *manager = [SDWebImageManager sharedManager]; // self.targetRect是用来判断是否在减速过程当中 // !CGRectIntersectsRect([self.targetRect CGRectValue], cellFrame)是用来判断出现的cell是否在目标区域 // 4.这两个判断合起来的意思是:tableView正处于减速过程,显示的cell也不在目标区域才为真 if (aTargetRect &amp;&amp; !CGRectIntersectsRect([aTargetRect CGRectValue], aCellFrame)) &#123; SDImageCache *cache = [manager imageCache]; NSString *key = [manager cacheKeyForURL:imageURL]; // 如果不存磁盘 只需要改成imageFromeMemoryCacheForkey: if (![cache imageFromDiskCacheForKey:key]) &#123; shouldLoadImage = NO; &#125; &#125; UIImage *placeholderImage = [UIImage imageNamed:@&quot;&quot;]; //3. 加载图片 if (shouldLoadImage) &#123; [self lad_setImageFadeInWithURL:imageURL placeholderImage:placeholderImage]; &#125;else &#123; self.image = placeholderImage; &#125; &#125;&#125;@end 2.UIImageView+LEOAnimationLoad动画过渡效果的实现代码: 1234567891011121314151617181920212223242526@implementation UIImageView (LEOAnimationLoad)- (void)lad_setImageFadeInWithURL:(NSURL *)url placeholderImage:(UIImage *)placehoderImage &#123; [self lad_setImageWithURL:url placeholderImage:placehoderImage options:SDWebImageRetryFailed | SDWebImageLowPriority duratingTime:0.5f];&#125;- (void)lad_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)image options:(SDWebImageOptions)option duratingTime:(NSTimeInterval)duration &#123; [self sd_setImageWithURL:url placeholderImage:image options:option completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, NSURL *imageURL) &#123; //针对没缓存过的图片做动画 if (image &amp;&amp; cacheType == SDImageCacheTypeNone) &#123; CATransition *fadeIn = [CATransition animation]; fadeIn.type = @&quot;fade&quot;; fadeIn.duration = duration; fadeIn.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseIn]; [self.layer addAnimation:fadeIn forKey:@&quot;fadeIn&quot;]; &#125; &#125;];&#125;@end 最后别忘了在tableView:cellForRowAtIndexPath:方法中对cell进行图片加载操作: 1234567__weak typeof(self) weakSelf = self; LEOTableViewCellConfigBlock configCellBlock = ^(LEOImageCell *cell, NSDictionary *itemDic,NSIndexPath *currentIndexPath) &#123; CGRect cellFrame = [weakSelf.showImageTableView rectForRowAtIndexPath:currentIndexPath]; [cell loadVisibleWithItem:itemDic targetRect:weakSelf.targetRect cellFrame:cellFrame]; &#125;; 我这里是对tableView的dataSource抽离到了另一个单独类中(瘦Controller处理),通过block回调来实现的,block中的代码就相当于写在了tableView:cellForRowAtIndexPath:中。 另外要注意,在这里我通过创建UIViewController的Category来实现tableView的那三个代理方法,意思是说: 只要tableView的代理对象是UIViewController就会触发Category中的代理方法,如果其他UIViewController的Category也实现了这些协议方法,编译器将决定以最后添加的那个Category为主(Category的特性)。 如果要在当前的UIViewController重写Category中的这三个代理方法,那么需要把Category中的实现代码也要copy过去,因为重写过后Category中的实现就没用了。 可以考虑把这三个代理方法从UIViewController的Category中转移到具体的基类当中 至此对图片加载这一块的优化就做完了,代码已上传GitHub,欢迎指正与吐槽。^ ^","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://leonzlw.github.io/tags/iOS/"}]},{"title":"iBeacon调研实践(二)","slug":"iBeacon2","date":"2016-07-21T06:26:36.000Z","updated":"2018-02-05T19:39:09.000Z","comments":true,"path":"2016/07/21/iBeacon2/","link":"","permalink":"http://leonzlw.github.io/2016/07/21/iBeacon2/","excerpt":"iBeacon调研记录(一)主要介绍了iBeacon(Bluetooth Low Energy)是什么,使用场景,API介绍及注意事项。如果看过了上篇文章,相信你对iBeacon已经有了初步了解,这篇文章主要是利用上一篇所记录的内容写一个方便监视iBeacon设备信号动态变化和修改监视区域参数的工具。 简单描述一下需求: 实时监测到iBeacon信号变化 可以方便添加/删除/修改监视的iBeacon 从边界进入到监视区域会通知用户 (在前台:弹出提示框 在后台:本地推送消息) 刚开始就在监视区域通知用户 (在前台:弹出提示框 在后台:本地推送消息) 同一区域不重复性提示用户 看了上面的需求,首先我们要有一个列表用来展示所有iBeacon信号变化,当进行添加/修改操作的时候,需要跳转到一个新的页面去编辑,编辑完成之后再跳回到iBeacon列表页面,页面的简单操作描述就是这样。 最终在真机下的效果:","text":"iBeacon调研记录(一)主要介绍了iBeacon(Bluetooth Low Energy)是什么,使用场景,API介绍及注意事项。如果看过了上篇文章,相信你对iBeacon已经有了初步了解,这篇文章主要是利用上一篇所记录的内容写一个方便监视iBeacon设备信号动态变化和修改监视区域参数的工具。 简单描述一下需求: 实时监测到iBeacon信号变化 可以方便添加/删除/修改监视的iBeacon 从边界进入到监视区域会通知用户 (在前台:弹出提示框 在后台:本地推送消息) 刚开始就在监视区域通知用户 (在前台:弹出提示框 在后台:本地推送消息) 同一区域不重复性提示用户 看了上面的需求,首先我们要有一个列表用来展示所有iBeacon信号变化,当进行添加/修改操作的时候,需要跳转到一个新的页面去编辑,编辑完成之后再跳回到iBeacon列表页面,页面的简单操作描述就是这样。 最终在真机下的效果: 在开撸之前,还要了解一下CLBeaconRegion和CLBeacon: CLBeaconRegion:用来设置监视区域的行为特征(比如:设置notifyEntryStateOnDisplay=YES),还有存放监视区域的UUID,Major,Minor等信息。 CLBeacon:相当于我们的iBeacon设备信息,我们不仅可以从中获取到UUID,Major,Minor,还能获取到accuracy(距离),RSSI(信号强度)等信息。 开撸! 首先我们要在新建工程的info.plist文件中添加Privacy - Location When In Use Usage Description 或 Privacy - Location Always Usage Description来告诉系统我们要使用定位服务,苹果把iBeacon集成到了&lt;CoreLocation/CoreLocation.h&gt;框架中,由CLLocationManager来管理。 在iBeacon列表控制器,声明这三个属性: 1234567891011121314151617181920212223242526272829303132@interface IBMBeaconViewController ()&lt;CLLocationManagerDelegate, UITableViewDelegate, UITableViewDataSource&gt;// 定位管理@property (nonatomic, strong) CLLocationManager *locationManager;// 存放IBMBeaconItem的数组@property (nonatomic, strong) NSMutableArray *beaconItems;// tableView视图@property (weak, nonatomic) IBOutlet UITableView *beaconTableView;@end// 在实现中利用懒加载初始化,beaconTableView是在storyboard的控件,无需代码初始化@implementation IBMBeaconViewController- (CLLocationManager *)locationManager &#123; if (!_locationManager) &#123; _locationManager = [[CLLocationManager alloc]init]; _locationManager.delegate = self; // iOS8后要手动授权 [_locationManager requestWhenInUseAuthorization]; &#125; return _locationManager;&#125;- (NSMutableArray *)beaconItems &#123; if (!_beaconItems) &#123; _beaconItems = [NSMutableArray array]; &#125; return _beaconItems;&#125;@end beaconItems中存放的是IBMBeaconItem类的实例,IBMBeaconItem用来存放iBeacon的信息: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#import &lt;CoreLocation/CoreLocation.h&gt;@interface IBMBeaconItem : NSObject&lt;NSCoding&gt;// 设备的名字(identifier)@property (strong, nonatomic, readonly) NSString *name;@property (strong, nonatomic, readonly) NSUUID *uuid;@property (assign, nonatomic, readonly) CLBeaconMajorValue majorValue;@property (assign, nonatomic, readonly) CLBeaconMinorValue minorValue;// 记录每次通知的时间@property (nonatomic, strong) NSDate *lastNotifyDate;// 匹配的CLBeacon@property (nonatomic, strong) CLBeacon *beaconMatching;- (instancetype)initWithName:(NSString *)name uuid:(NSUUID *)uuid major:(CLBeaconMajorValue)major minor:(CLBeaconMinorValue)minor;/** 判断IBMBeaconItem实例的信息是否与检测到的区域相同 @param beaconRegion CLBeaconRegion区域实例 @return 判断结果 */- (BOOL)isEqualToCLBeaconRegion:(CLBeaconRegion *)beaconRegion;/** 判断是否需要发送通知(当前时间 - 上次通知记录的时间(lastNotifyDate) &gt; 规定的时间 就返回YES发送通知 否则NO) @return 判断结果 */- (BOOL)shouldSendNotificaiton;/** 判断IBMBeaconItem实例的信息是否与检测到的设备信息相同 @param beacon 设备实例 @return 判断结果 */- (BOOL)isEqualToCLBeacon:(CLBeacon *)beacon;@end// 下面是实现类.m#import &quot;IBMBeaconItem.h&quot;static NSString *const ibeaconName = @&quot;ibeaconName&quot;;static NSString *const iBeaconUUID = @&quot;iBeaconUUID&quot;;static NSString *const iBeaconMajor = @&quot;iBeaconMajor&quot;;static NSString *const iBeaconMinor = @&quot;iBeaconMinor&quot;;static NSString *const iBeaconLastNotifyDate = @&quot;iBeaconLastNotifyDate&quot;;// 过期时间间隔,默认是10.0s (当前时间 - 上次发送通知时间 &gt; expiredTime 就发送通知)static const NSTimeInterval expiredTime = 10.0;@implementation IBMBeaconItem- (instancetype)initWithName:(NSString *)name uuid:(NSUUID *)uuid major:(CLBeaconMajorValue)major minor:(CLBeaconMinorValue)minor&#123; self = [super init]; if (self) &#123; _name = name; _uuid = uuid; _majorValue = major; _minorValue = minor; &#125; return self;&#125;- (instancetype)initWithCoder:(NSCoder *)aDecoder &#123; self = [super init]; if (self) &#123; _name = [aDecoder decodeObjectForKey:ibeaconName]; _uuid = [aDecoder decodeObjectForKey:iBeaconUUID]; _majorValue = [[aDecoder decodeObjectForKey:iBeaconMajor] unsignedIntegerValue]; _minorValue = [[aDecoder decodeObjectForKey:iBeaconMinor] unsignedIntegerValue]; _lastNotifyDate = [aDecoder decodeObjectForKey:iBeaconLastNotifyDate]; &#125; return self;&#125;- (void)encodeWithCoder:(NSCoder *)aCoder &#123; [aCoder encodeObject:self.name forKey:ibeaconName]; [aCoder encodeObject:self.uuid forKey:iBeaconUUID]; [aCoder encodeObject:@(self.majorValue) forKey:iBeaconMajor]; [aCoder encodeObject:@(self.minorValue) forKey:iBeaconMinor]; [aCoder encodeObject:self.lastNotifyDate forKey:iBeaconLastNotifyDate];&#125;- (BOOL)isEqualToCLBeaconRegion:(CLBeaconRegion *)beaconRegion &#123; return [self isEqualToBeaconInfo:beaconRegion];&#125;- (BOOL)isEqualToBeaconInfo:(id)beaconInfo &#123; if ([[[beaconInfo valueForKey:@&quot;proximityUUID&quot;] UUIDString] isEqualToString:[self.uuid UUIDString]] &amp;&amp; [[beaconInfo valueForKey:@&quot;major&quot;] isEqual: @(self.majorValue)] &amp;&amp; [[beaconInfo valueForKey:@&quot;minor&quot;] isEqual: @(self.minorValue)]) &#123; return YES; &#125; else &#123; return NO; &#125;&#125;- (BOOL)isEqualToCLBeacon:(CLBeacon *)beacon &#123; return [self isEqualToBeaconInfo:beacon];&#125;- (BOOL)shouldSendNotificaiton &#123; if (self.lastNotifyDate == nil) &#123; [self updateLastNotifyDate]; return YES; &#125;else &#123; NSTimeInterval timeInterval = [[NSDate date] timeIntervalSinceDate:self.lastNotifyDate]; BOOL isNeedUpdate = timeInterval &gt; expiredTime ? YES : NO; if (isNeedUpdate) &#123; [self updateLastNotifyDate]; return YES; &#125;else &#123; return NO; &#125; &#125;&#125;- (void)setLastNotifyDate:(NSDate *)lastNotifyDate &#123; if (lastNotifyDate) &#123; _lastNotifyDate = lastNotifyDate; &#125;&#125;- (void)updateLastNotifyDate &#123; self.lastNotifyDate = [[NSDate alloc] initWithTimeIntervalSinceNow:0];&#125;- (NSString *)description &#123; NSString *descriptionStr = [NSString stringWithFormat:@&quot;name=%@\\n uuid=%@ \\n majorValue=%d minorValue=%d \\n lastNotifyDate=%@&quot;, _name,_uuid,_majorValue,_minorValue, _lastNotifyDate]; return descriptionStr;&#125;@end 我们不希望每次添加完iBeacon监视区域重新启动程序后添加的数据就没了,所以要做本地持久化处理,而且要在工程的任何地方都要能够访问到(如:Appdelegate中),所以创建了一个用单例初始化的类IBMBeaconItemManager来管理: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#import &quot;IBMBeaconItem.h&quot;typedef void(^TraverseBeaconItemHandle)(IBMBeaconItem *item);@interface IBMBeaconItemManager : NSObject// 存放IBMBeaconItem对象转化成Data类型后的数组@property (nonatomic, copy, readonly) NSArray&lt;NSData *&gt; *storeItemsData;// 存放IBMBeaconItem对象的数组@property (nonatomic, copy, readonly) NSArray&lt;IBMBeaconItem *&gt; *storeItems;+ (instancetype)sharedInstanced;/** 同步本地数据,比如在客户端我们在做添加/删除/修改 操作的时候,要与本地的数据同步一下 @param latestItems 要同步的数组&lt;IBMBeaconItem *&gt; */- (void)syncStoreItemsWithLatestItems:(NSArray&lt;IBMBeaconItem *&gt; *)latestItems;/** 遍历本地存放的ItemData,把Data转化成IBMBeaconItem并每一次遍历都会把IBMBeaconItem通过TraverseBeaconItemHandle传到调用的地方,详情请看实现代码 @param itemHandle Block */- (void)TraverseStoreItemsHandle:(TraverseBeaconItemHandle)itemHandle;@end// IBMBeaconItemManager.m实现代码#import &quot;IBMBeaconItemManager.h&quot;// 本地存储Key值static NSString *const beaconItemsStoreKey = @&quot;beaconItemsStoreKey&quot;;@implementation IBMBeaconItemManager@synthesize storeItemsData = _storeItemsData;@synthesize storeItems = _storeItems;+ (instancetype)sharedInstanced &#123; static IBMBeaconItemManager *manager; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; manager = [[self alloc]init]; &#125;); return manager;&#125;- (void)TraverseStoreItemsHandle:(TraverseBeaconItemHandle)itemHandle &#123; if (self.storeItemsData) &#123; for (NSData *itemData in _storeItemsData) &#123; IBMBeaconItem *ibeaconItem = [NSKeyedUnarchiver unarchiveObjectWithData:itemData]; itemHandle(ibeaconItem); &#125; &#125;&#125;- (void)syncStoreItemsWithLatestItems:(NSArray&lt;IBMBeaconItem *&gt; *)latestItems &#123; NSMutableArray *cacheItemsData = [NSMutableArray array]; for (IBMBeaconItem *item in latestItems) &#123; NSData *itemData = [NSKeyedArchiver archivedDataWithRootObject:item]; [cacheItemsData addObject:itemData]; &#125; _storeItemsData = [cacheItemsData copy]; _storeItems = [latestItems copy]; [[NSUserDefaults standardUserDefaults] setObject:_storeItemsData forKey:beaconItemsStoreKey]; [[NSUserDefaults standardUserDefaults] synchronize]; &#125;- (NSArray&lt;NSData *&gt; *)storeItemsData &#123; if (!_storeItemsData) &#123; _storeItemsData = [[NSUserDefaults standardUserDefaults] objectForKey:beaconItemsStoreKey]; &#125; return _storeItemsData;&#125;- (NSArray&lt;IBMBeaconItem *&gt; *)storeItems &#123; if (!_storeItems) &#123; NSMutableArray *mutableStoreItems = [NSMutableArray array]; if (self.storeItemsData) &#123; for (NSData *itemData in _storeItemsData) &#123; IBMBeaconItem *ibeaconItem = [NSKeyedUnarchiver unarchiveObjectWithData:itemData]; [mutableStoreItems addObject:ibeaconItem]; &#125; &#125; _storeItems = [mutableStoreItems copy]; &#125; return _storeItems;&#125;@end 有了IBMBeaconItem和IBMBeaconItemManager后,进入iBeacon列表控制器,在viewDidload中调用loadIbeaconItem方法: 12345678910111213141516171819202122232425262728293031#pragma mark - 步骤1- (void)loadIbeaconItem &#123; // 读取本地数据 [[IBMBeaconItemManager sharedInstanced] TraverseStoreItemsHandle:^(IBMBeaconItem *item) &#123; // 每取到一个IBMBeaconItem 开始对它进行监听 [self startMonitoringWithItem:item]; // 添加到tableView的资源数组 [self.beaconItems addObject:item]; &#125;];&#125;#pragma mark - 步骤2- (void)startMonitoringWithItem:(IBMBeaconItem *)ibeaconItem &#123; CLBeaconRegion *beaconRegion = [self generateBeaconRegionWithItem:ibeaconItem]; [self.locationManager startMonitoringForRegion:beaconRegion]; [self.locationManager startRangingBeaconsInRegion:beaconRegion];&#125;#pragma mark - 步骤3- (CLBeaconRegion *)generateBeaconRegionWithItem:(IBMBeaconItem *)ibeaconItem &#123; // 生成iBeacon区域实例,表示我们要监视的区域 CLBeaconRegion *beaconRegion = [[CLBeaconRegion alloc]initWithProximityUUID:ibeaconItem.uuid major:ibeaconItem.majorValue minor:ibeaconItem.minorValue identifier:ibeaconItem.name]; // 从黑屏-&gt;亮屏 通知- (void)locationManager:didDetermineState:forRegion:代理方法 beaconRegion.notifyEntryStateOnDisplay = YES; return beaconRegion;&#125; 这样,我们就开始对iBeacon区域开启了监视,剩下的就是我们要在Appdelegate类中去实现locationManager:didEnterRegion:,locationManager:didExitRegion:,locationManager:didDetermineState:forRegion:代理方法,为什么要写在Appdelegate类中,请看上篇文章,这里要注意一下:当我将window的rootViewController设置为iBeacon列表控制器,并把所有代理方法实现都写到iBeacon列表控制器中,关闭程序后,依然会调用到代理方法,如果iBeacon列表控制器不设置为window的rootViewController就无法调用到了。所以我们把剩下监测到iBeacon通知的逻辑写到Appdelegate类中: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124@interface AppDelegate ()&lt;CLLocationManagerDelegate, UIApplicationDelegate&gt;@property (nonatomic, strong) CLLocationManager *locationManager;@end@implementation AppDelegate- (BOOL)application:(UIApplication *)applicationdidFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; self.locationManager.delegate = self; return YES;&#125;#pragma mark - 本地通知接收- (void)application:(UIApplication *)applicationdidReceiveLocalNotification:(UILocalNotification *)notification &#123; [self alertMessage:notification.alertBody];&#125;#pragma mark - CLLocationManagerDelegate// 进入到iBeacon区域(会有延迟,大概30s)- (void)locationManager:(CLLocationManager *)manager didEnterRegion:(CLRegion *)region &#123; if ([region isKindOfClass:[CLBeaconRegion class]]) &#123; CLBeaconRegion *beaconRegion = (CLBeaconRegion *)region; [self matchIbeaconRegion:beaconRegion]; &#125;&#125;- (void)locationManager:(CLLocationManager *)manager didExitRegion:(CLRegion *)region &#123; NSLog(@&quot;离开iBeacon区域&quot;);&#125;// requestStateForRegion:方法调用就会触发该代理方法,另外从黑屏到亮屏过程也会触发- (void)locationManager:(CLLocationManager *)manager didDetermineState:(CLRegionState)state forRegion:(CLRegion *)region &#123; switch (state) &#123; case CLRegionStateUnknown: &#123; NSLog(@&quot;未知&quot;); &#125; break; case CLRegionStateInside: &#123; NSLog(@&quot;在iBeacon区域里面&quot;); if ([region isKindOfClass:[CLBeaconRegion class]]) &#123; CLBeaconRegion *beaconRegion = (CLBeaconRegion *)region; [self matchIbeaconRegion:beaconRegion]; &#125; &#125; break; case CLRegionStateOutside: &#123; NSLog(@&quot;在iBeacon区域外面&quot;); &#125; break; &#125;&#125;// CLBeaconRegion 来匹配与之对应的 IBMBeaconItem- (void)matchIbeaconRegion:(CLBeaconRegion *)ibeaconRegion &#123; NSArray&lt;IBMBeaconItem *&gt; * beaconItems = [IBMBeaconItemManager sharedInstanced].storeItems; for (IBMBeaconItem *item in beaconItems) &#123; if ([item isEqualToCLBeaconRegion:ibeaconRegion]) &#123; [self sendLocalNotificationWithIbeaconItem:item]; &#125; &#125;&#125;// 弹出提示框- (void)alertMessage:(NSString *)message &#123; UIAlertView *alertView = [[UIAlertView alloc]initWithTitle:@&quot;提示&quot; message:message delegate:nil cancelButtonTitle:@&quot;确定&quot; otherButtonTitles:nil]; [alertView show];&#125;// 发送本地通知(弹出框)- (void)sendLocalNotificationWithIbeaconItem:(IBMBeaconItem *)ibeaconItem &#123; if ([ibeaconItem shouldSendNotificaiton]) &#123; NSString *notifyString = [NSString stringWithFormat:@&quot;进入%@的iBeacon区域&quot;,ibeaconItem.name]; UIApplicationState appState = [UIApplication sharedApplication].applicationState; switch (appState) &#123; case UIApplicationStateActive: // 在前台 &#123; [self alertMessage:notifyString]; break; &#125; case UIApplicationStateBackground: // 在后台 &#123; // 通知的代码 UILocalNotification *notice = [[UILocalNotification alloc] init]; notice.alertBody = notifyString; // notice.alertAction = @&quot;iBeacon区域提醒&quot;; [[UIApplication sharedApplication] scheduleLocalNotification:notice]; UIUserNotificationSettings *settings = [UIUserNotificationSettings settingsForTypes:UIUserNotificationTypeBadge | UIUserNotificationTypeSound | UIUserNotificationTypeAlert categories:nil]; [[UIApplication sharedApplication] registerUserNotificationSettings:settings]; break; &#125; default: break; &#125; &#125; &#125;- (CLLocationManager *)locationManager &#123; if (!_locationManager) &#123; _locationManager = [[CLLocationManager alloc]init]; &#125; return _locationManager;&#125;@end 核心的监测代码就完成啦,剩下的展示内容,新增/修改/删除操作具体实现过程可参考Demo！","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://leonzlw.github.io/tags/iOS/"}]},{"title":"iBeacon调研记录(一)","slug":"iBeacon","date":"2016-07-15T10:47:20.000Z","updated":"2018-02-05T19:39:02.000Z","comments":true,"path":"2016/07/15/iBeacon/","link":"","permalink":"http://leonzlw.github.io/2016/07/15/iBeacon/","excerpt":"最近公司机场的广告机项目要实现用户只要走近机器就在手机上推送广告消息的功能,基于这一点让我想到了苹果公司iOS7推出的iBeacon定位技术,之前也没有实际使用过,趁着项目需要,边研究边记录。 iBeaconiBeacon的底层技术是采用的低功耗蓝牙技术(Bluetooth Low Energy),它与传统的蓝牙概括有这几点区别: 耗电量:持续运作的时间更长,estimote声称可以运作24个月,具体的运作时间还是和iBeacon设备的广播频率周期有关。 低成本:iBeacon设备的成本相当于传统蓝牙设备的60%-80%。 应用:iBeacon设备适用于只要求少量定期传输数据的简单应用,传统的蓝牙适用于需要持续通信和大量数据传输的复杂应用。","text":"最近公司机场的广告机项目要实现用户只要走近机器就在手机上推送广告消息的功能,基于这一点让我想到了苹果公司iOS7推出的iBeacon定位技术,之前也没有实际使用过,趁着项目需要,边研究边记录。 iBeaconiBeacon的底层技术是采用的低功耗蓝牙技术(Bluetooth Low Energy),它与传统的蓝牙概括有这几点区别: 耗电量:持续运作的时间更长,estimote声称可以运作24个月,具体的运作时间还是和iBeacon设备的广播频率周期有关。 低成本:iBeacon设备的成本相当于传统蓝牙设备的60%-80%。 应用:iBeacon设备适用于只要求少量定期传输数据的简单应用,传统的蓝牙适用于需要持续通信和大量数据传输的复杂应用。 iBeacon标识组成iBeacon主要是由proximityUUID,major,minor来标识: proximityUUID(唯一标识):一个128位的值,用它来作为唯一标识,它与我们传统理解的唯一标识有一些区别,它可以是多个ibeacon设备同时使用一个UUID标识。 major(主要值):一个16位无符号整数,用于区分拥有相同proximityUUID值的iBeacon设备。 minor(次要值):一个16位无符号整数,用于区分拥有相同proximityUUID和major的iBeacon设备。 可以通过 proximityUUID + major + minor 来确定一个iBeacon设备,可以有这几种组合: proximityUUID + 空值major + 空值minor proximityUUID + 非空major + 空值minor proximityUUID + 空值major + 非空minor proximityUUID + 非空major + 非空minor major和minor可以为空值,如果是空的情况,扫描的时候只需要去校验proximityUUID是否匹配即可。 使用场景比如我们的广告机设备要投放到全国各地的机场场景,那么可以用proximityUUID来标记公司,major来标记城市,minor来标记具体机场(有些城市有两个机场的情况),这样就可以确定ibeacon设备在哪个城市的哪个机场了。最终怎样去组合标记,根据实际的需求而定。 API介绍Apple把iBeacon功能集成到了Core location框架里面,所以在我们要使用的类中引入&lt;CoreLocation/CoreLocation.h&gt;。 如果我们想扫描到周围的iBeacon设备,首先要知道周围ibeacon设备的proximityUUID,major,minor,然后要用CLBeaconRegion类的实例来定义iBeacon的区域: 12345// 周围有多个iBeacon的话就根据iBeacon设备的参数信息逐个CLBeaconRegion实例,这里我只初始化一个来说明CLBeaconRegion *beaconRegion = [[CLBeaconRegion alloc]initWithProximityUUID:@&quot;UUID&quot; major:10084 minor:14406 identifier:@&quot;标识内容&quot;]; 接下来我们要创建CLLocationManager管理对象,因为我们想要监控iBeacon设备就是由它来控制的,CLLocationManager类的实例方法主要有下面这几个方法来监视iBeacon区域: startMonitoringForRegion: 这个方法是开启对iBeacon区域的监视,通过官方API文档我们可以了解到,开启监听后当我们进入iBeacon区域和走出iBeacon区域会分别调用CLLocationManagerDelegate的代理方法 locationManager:didEnterRegion: 和 locationManager:didExitRegion:,如果出错了的话会回调 locationManager:monitoringDidFailForRegion:withError:方法,这个方法只能同时监测20个iBeacon区域,也不能得到手机设备与iBeacon设备的距离。如果要取消监听了的话,调用 stopMonitoringForRegion:方法停止。这里要注意的是:在监测的过程中,locationManager:didEnterRegion:和 locationManager:didExitRegion:方法回调是会有延迟的,经过测试,延迟大概在30s左右,有可能会更长也有可能会短一些,这些是都是由苹果控制的,所以在测试的过程确实会很蛋疼。还有一点要注意的:只有当你从ibeacon区域出入时必须经过零界点时才会触发代理方法的调用,如果你开始就在iBeacon区域内没有出去,就不会调用代理方法了。 requestStateForRegion: 调用这个方法会异步监听当前区域是否在iBeacon区域内,并将结果通过代理方法 locationManager:didDetermineState:forRegion:返回,我们可以通过state值: CLRegionStateUnknown, CLRegionStateInside, CLRegionStateOutside来确定你的位置是否在iBeacon区域。 startRangingBeaconsInRegion: 这个方法相当于按一定频率去扫描iBeacon设备,频率大概是1s/次,扫描结果通过 locationManager:didRangeBeacons:inRegion: 代理方法返回,我们可以从中得到beacons数组,数组中存放的是CLBeacon类的实例,它们是由近到远的顺序排列的,数组中的第一个是最近的iBeacon设备,以此类推。我们通过数组中的实例对象可以获得iBeacon设备的信息和相距的具体距离accuracy还有rrsi(信号强度)值。如果需要停止扫描的话,调用 stopRangingBeaconsInRegion:方法。 开启监听模式: 1234567891011CLBeaconRegion *beaconRegion = [[CLBeaconRegion alloc]initWithProximityUUID:@&quot;UUID&quot; major:10084 minor:14406 identifier:@&quot;标识字段&quot;];beaconRegion.notifyOnEntry = NO;beaconRegion.notifyOnExit = NO;beaconRegion.notifyEntryStateOnDisplay = YES; [self.locationManager startMonitoringForRegion:beaconRegion];[self.locationManager requestStateForRegion:beaconRegion];[self.locationManager startRangingBeaconsInRegion:beaconRegion]; 上面的代码我们为beaconRegion的属性做了赋值操作,接下来介绍一下notifyOnEntry,notifyOnExit,notifyEntryStateOnDisplay属性的作用: notifyOnEntry: 设置进入iBeacon区域时是否调用代理方法 locationManager:didEnterRegion:,默认状态是YES notifyOnExit: 设置走出iBeacon区域时是否调用代理方法 locationManager:didExitRegion:,默认状态是YES notifyEntryStateOnDisplay: 设置当在iBeacon区域时屏幕关闭再亮屏是否触发代理方法locationManager:didDetermineState:forRegion:,如果值为YES那么不论应用在前台或后台,只要按一下电源键-&gt;黑屏了,再按一下电源键-&gt;点亮屏幕 都会调用这个代理方法,按home键退出桌面再进入程序前台是不会触发代理方法的。默认状态是NO。 这里要特别说明一下notifyOnEntry和notifyOnExit属性,官方文档是这样描述的: notifyOnEntry: When this property is YES, a device crossing from outside the region to inside the region triggers the delivery of a notification. If the property is NO, a notification is not generated. The default value of this property is YES. If the app is not running when a boundary crossing occurs, the system launches the app into the background to handle it. Upon launch, your app must configure new location manager and delegate objects to receive the notification. The notification is sent to your delegate’s locationManager:didEnterRegion: method. notifyOnExit When this property is YES, a device crossing from inside the region to outside the region triggers the delivery of a notification. If the property is NO, a notification is not generated. The default value of this property is YES. If the app is not running when a boundary crossing occurs, the system launches the app into the background to handle it. Upon launch, your app must configure new location manager and delegate objects to receive the notification. The notification is sent to your delegate’s locationManager:didExitRegion: method. 可是经过测试,不论设置为YES或NO,当经过iBeacon区域时都会触发 locationManager:didEnterRegion: 和 locationManager:didExitRegion: 代理方法,具体什么原因还没搞清楚,我已在github和stack overflow提问,有了解的朋友还望指点。 后台和程序关闭的行为苹果对iBeacon是支持后台和杀掉应用进程后还能保持监测行为的,而且你也能拿到你监视区域的信息,因为当你在程序的任何地方调用startMonitoringForRegion: 添加监视区域,这些监视区域都会被CLLocationManager管理着。我们只需要在AppDelegate类中实现CLLocationManagerDelegate代理,创建CLLocationManager对象,并设置其delegate为self,在后台或应用关闭后,只要你从边界进入iBeacon区域或离开iBeacon区域都会触发 locationManager:didEnterRegion: 和 locationManager:didExitRegion: 代理方法,如果你设置了notifyEntryStateOnDisplay=YES,当屏幕从黑屏亮起来的时候,如果身在iBeacon区域也会执行 locationManager:didDetermineState:forRegion: 代理方法,但是当程关闭的时候 locationManager:didRangeBeacons:inRegion: 代理方法是不会被执行的,如果需要的话,可以考虑在AppDelegate中调用 startRangingBeaconsInRegion: 实例方法来实现! 为什么要在AppDelegate中实现上面几个代理方法? 因为苹果规定的这一机制,如果app处于关闭的状态,进入到了监控的区域,它只能在AppDelegate类中响应。比如:我们在其他页面添加了监视区域,并将这些响应的代理方法都在写在了该页面,当程序处于关闭状态,只要你不打开App进入到这个页面,那么这些代理方法是不会被执行到的。 本节主要是了解一下iBeacon是什么以及API的基本使用,相对来说还是比较简单的,但是在初探的过程中调试起来还是比较费事儿的,主要体现在监测到iBeacon的时间延迟没有规律,有时很快就监测到,有时延迟长达几分钟之久。 参考链接: http://objcio.com/blog/2014/05/01/can-you-smell-the-ibeacon/ http://developer.radiusnetworks.com/2013/11/13/ibeacon-monitoring-in-the-background-and-foreground.html http://southpeak.github.io/2014/07/27/ibeacon-exploration/","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://leonzlw.github.io/tags/iOS/"}]},{"title":"iOS应用间通信","slug":"URL-Schemes","date":"2016-07-07T04:57:27.000Z","updated":"2018-02-05T19:38:43.000Z","comments":true,"path":"2016/07/07/URL-Schemes/","link":"","permalink":"http://leonzlw.github.io/2016/07/07/URL-Schemes/","excerpt":"我们在日常使用移动应用产品时经常会遇到正在使用的这款APP在操作中经常会跳转到另一款APP中去操作,比如支付宝支付,微信支付,微博分享等。这不禁让我们联想到苹果的沙盒机制,受苹果的这一机制影响,我们不能应用之间资源共享,也就是说我们的应用都是独立的块,应用内所需要的资源都是自给自足不受外界的”救济”,那么应用之间通信的行为就是通过URL Schemes来实现的。 URL Schemes我们通过对比网页链接来理解iOS上的 URL Schemes。 URL Schemes有两个单词: URL:链接地址或网址,https://www.baidu.com 就是一个URL。 Schemes:表示的是URL中的最初位置,即://之前的那段字符,比如 https://www.baidu.com 这个URL的Schemes就是https。 根据上面对URL Schemes的理解,我们在iOS中如果想定位到某个APP,只需要知道 Schemes 部分就可以做到了,比如我们要打开微信这个APP,我们只需要知道微信的 Schemes 是 wexin ,在后面拼接上 :// 即: wexin://然后在 safari 浏览器输入网址的地方输入 wexin:// 确认后就会在屏幕中弹出 在&quot;微信&quot;中打开链接吗? 的提示框,当你选择打开操作后就会自动跳转到微信界面了。 目前我们仅仅是定位到了某个APP,如果想跳转到这个APP并让它做一些我们想要的操作的话,我们需要在://后面跟一些路径参数让它定位到具体的功能或页面: 网页(百度) iOS应用(微信) 网站首页: https://www.baidu.com 打开应用: wexin:// 子页面: https://www.baidu.com/duty(百度免责声明页面) wexin://dl/moments (朋友圈)","text":"我们在日常使用移动应用产品时经常会遇到正在使用的这款APP在操作中经常会跳转到另一款APP中去操作,比如支付宝支付,微信支付,微博分享等。这不禁让我们联想到苹果的沙盒机制,受苹果的这一机制影响,我们不能应用之间资源共享,也就是说我们的应用都是独立的块,应用内所需要的资源都是自给自足不受外界的”救济”,那么应用之间通信的行为就是通过URL Schemes来实现的。 URL Schemes我们通过对比网页链接来理解iOS上的 URL Schemes。 URL Schemes有两个单词: URL:链接地址或网址,https://www.baidu.com 就是一个URL。 Schemes:表示的是URL中的最初位置,即://之前的那段字符,比如 https://www.baidu.com 这个URL的Schemes就是https。 根据上面对URL Schemes的理解,我们在iOS中如果想定位到某个APP,只需要知道 Schemes 部分就可以做到了,比如我们要打开微信这个APP,我们只需要知道微信的 Schemes 是 wexin ,在后面拼接上 :// 即: wexin://然后在 safari 浏览器输入网址的地方输入 wexin:// 确认后就会在屏幕中弹出 在&quot;微信&quot;中打开链接吗? 的提示框,当你选择打开操作后就会自动跳转到微信界面了。 目前我们仅仅是定位到了某个APP,如果想跳转到这个APP并让它做一些我们想要的操作的话,我们需要在://后面跟一些路径参数让它定位到具体的功能或页面: 网页(百度) iOS应用(微信) 网站首页: https://www.baidu.com 打开应用: wexin:// 子页面: https://www.baidu.com/duty(百度免责声明页面) wexin://dl/moments (朋友圈) 通过上面的表格对比异同: 不同点:定位到网站首页需要一个完整的URL,而定位某个应用需要 Schemes 后面拼接上 ://。 相同点:网站定位到具体的某个页面都需要提供路径,比如定位到百度的免责声明页面需要在 https://www.baidu.com 后面拼接/duty,iOS应用中定位到APP的具体功能或页面需要在 wexin:// 后面拼接 dl/moments。 补充: 苹果没有硬性要求APP必须要有URL Schemes,所以我们所装的APP不是每一款都会有`URL Schemes,即使有URL Schemes也仅仅是能让我们从自己的应用A跳转到另一个应用B,如果想跳转到应用B后再根据你传递的内容跳转到具体的页面或执行某些功能,那么要看应用B的开发者是否制定了统一的参数规则在里面。 苹果没有要求URL Schemes是唯一的,所以不是每一个URL Schemes都对应一款应用,如果两个应用拥有相同的URL Schemes,当你通过这个URL Schemes去打开应用的时候,它会打开最后安装的那款APP。实践:你新建一个工程设置URL Schemes和支付宝的相同为 alipay,当你用饿了么订餐下单并通过支付宝支付的时候,发现跳转的是你生成的APP,因为支付宝在你的工程之前安装的。基于这一特性,曾经也出现过 App 使用支付宝的 URL Schemes 拦截支付帐号和密码的事件。 使用场景:假设我们要从应用URLSchemesB跳转到应用URLSchemesA,并要求应用URLSchemesA 弹出一个新的控制器,并根据传递的参数改变控制器的背景颜色,接下来我们来实现这一过程: 1.分别新创建URLSchemesA和URLSchemesB两个工程项目 2.在URLSchemesA工程的target-&gt;info中最下方的URL Types条目中新增URL Schemes: 3.然后在URLSchemesA工程info.plist文件中查看: 可以发现URL Schemes是一个数组,所以在它下面可以添加很多个Item,比方说我们又新增了一个URLSchemesAA,这样做是允许的,说明我们不仅可以通过URLSchemesA://打开APP,还可以使用URLSchemesAA://打开APP,就像微信一样自定义了很多URL Schemes,例如:weixin://,wechat://等。 4.由于我们要实现的不仅仅是简单的跳转过程,还包括跳转后 弹出控制器 + 改变控制器的背景色,所以我们要对URL制定统一规范(scheme://[target]/[action]?[params]),target指的是某个类,action指的是该类的具体方法,params指的是参数,根据这种规范我们生成符合我们要求的URL:URLSchemesA://SecondVC/setupBackgroundColorParmas?color=blueColor,具体代码如下: 123456789- (IBAction)clickedOpenURLSchemesA:(id)sender &#123; NSString *urlSchemesAStr = @&quot;URLSchemesA://SecondVC/setupBackgroundColorParmas?color=blueColor&quot;; NSURL *urlSchemesA = [NSURL URLWithString:urlSchemesAStr]; UIApplication *application = [UIApplication sharedApplication]; if ([application canOpenURL:urlSchemesA]) &#123; // 如果可以打开的话,在这里实现跳转 [application openURL:urlSchemesA]; &#125;&#125; 首先要用canOpenURL:方法判断是否可以打开指定的URL,如果手机中没有这个URL Schemes的应用,会返NO。还有就是iOS9之后,如果没有在info.plist中添加白名单,结果也会返回NO,并且会在控制台输出 1canOpenURL: failed for URL: &quot;URLSchemesA://&quot; - error: &quot;This app is not allowed to query for scheme URLSchemesA&quot; 这就需要我们把URLSchemesA添加到URLSchemesB工程的info.plist的白名单中: 5.当跳转到URLSchemesA时,如果是iOS9之前会调用AppDelegate类中的application:openURL:sourceApplication:annotation:方法,iOS9之后会调用application:openURL:options:方法,偷下懒- -,我就只写在application:openURL:options:了,代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// AppDelegate.m/** 通过指定的URL跳转到应用时调用(iOS9之前) @param url 指定的URL @param sourceApplication 请求打开应用的Bundle ID */- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation &#123; return YES;&#125;/** 通过指定的URL跳转到应用时调用(iOS9之后) @param url 指定的URL @param options 通过UIApplicationOpenURLOptionsSourceApplicationKey键可以获得请求打开应用的Bundle ID */- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;UIApplicationOpenURLOptionsKey,id&gt; *)options &#123; // 判断是否与自己自定义的URL Schemes相同 if (![url.scheme isEqualToString:@&quot;URLSchemesA&quot;]) &#123; return NO; &#125; NSLog(@&quot;从URLSchemesB应用跳转过来的Bundle ID:%@&quot;, options[UIApplicationOpenURLOptionsSourceApplicationKey]); // 获取类名 NSString *targetClass = url.host; // 获取要执行的方法名 NSString *actionName = [[url.path stringByReplacingOccurrencesOfString:@&quot;/&quot; withString:@&quot;&quot;] stringByAppendingString:@&quot;:&quot;]; SEL actionSEL = NSSelectorFromString(actionName); // 参数字符串转化为参数字典 NSMutableDictionary *params = [[NSMutableDictionary alloc] init]; NSString *urlString = [url query]; for (NSString *param in [urlString componentsSeparatedByString:@&quot;&amp;&quot;]) &#123; NSArray *elts = [param componentsSeparatedByString:@&quot;=&quot;]; if([elts count] &lt; 2) continue; [params setObject:[elts lastObject] forKey:[elts firstObject]]; &#125; UIViewController *secondVC = [[NSClassFromString(targetClass) alloc]init];#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot; [secondVC performSelector:actionSEL withObject:params];#pragma clang diagnostic pop [self.window.rootViewController presentViewController:secondVC animated:YES completion:nil]; return YES;&#125; 123456789// SecondVC.m- (void)setupBackgroundColorParmas:(NSDictionary *)params &#123; NSString *colorStr = params[@&quot;color&quot;]; if ([colorStr isEqualToString:@&quot;blueColor&quot;]) &#123; self.view.backgroundColor = [UIColor blueColor]; &#125;&#125; 当然,上述的这个简单例子只是我临时编造的一个情景,意在说明应用之间能够通过自定义URL Schemes来以这种方式通信,实际的使用情景比这要复杂的多,可能渗透到各个功能及业务模块之间,推荐大家看一下Casa Taloyum的组件化方案,其中也有谈及到应用之间的各模块调用。 这样就大工告成啦!Demo已上传至Github请点击这里查看。 相关技能如何获得手机中应用的URL Schemes? 以微信为例: 首先用电脑打开iTunes,然后在商店搜索微信并下载下来。 在资料库的iPhone应用中找到微信应用,右键在Finder中显示: 找到微信 6.5.5.ipa包所在目录后开始解压: 解压后在Payload文件下找到WeChat.app文件,右键显示包内容: 在wechat.app中搜索.plist文件: 在搜索到的众多info.plist中所搜URLSchemes关键字: 参考文献: Using URL Schemes to Communicate with Apps URL Schemes 使用详解","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://leonzlw.github.io/tags/iOS/"}]},{"title":"armv6,armv7,armv7s,arm64,i386,x86_64","slug":"ARM-CUP","date":"2016-07-01T16:10:37.000Z","updated":"2018-02-05T19:34:22.000Z","comments":true,"path":"2016/07/02/ARM-CUP/","link":"","permalink":"http://leonzlw.github.io/2016/07/02/ARM-CUP/","excerpt":"我们在xcode工程Build Settings中的Architectures一栏可以看到诸如armv7,arm64字样的配置信息,这类配置信息在我们日常开发过程中究竟起到什么作用,查阅了相关资料后在此整理一下。 指令集 指令集是存储在CPU内部，对CPU运算进行指导和优化的硬程序。拥有这些指令集，CPU就可以更高效地运行。Intel主要有x86，EM64T，MMX，SSE，SSE2，SSE3，SSSE3 (Super SSE3)，SSE4A，SSE4.1，SSE4.2，AVX，AVX2，AVX-512，VMX等指令集。AMD主要是x86，x86-64，3D-Now!指令集。 简单粗暴地理解下来就是指令集可以帮助CPU更高效地运行。","text":"我们在xcode工程Build Settings中的Architectures一栏可以看到诸如armv7,arm64字样的配置信息,这类配置信息在我们日常开发过程中究竟起到什么作用,查阅了相关资料后在此整理一下。 指令集 指令集是存储在CPU内部，对CPU运算进行指导和优化的硬程序。拥有这些指令集，CPU就可以更高效地运行。Intel主要有x86，EM64T，MMX，SSE，SSE2，SSE3，SSSE3 (Super SSE3)，SSE4A，SSE4.1，SSE4.2，AVX，AVX2，AVX-512，VMX等指令集。AMD主要是x86，x86-64，3D-Now!指令集。 简单粗暴地理解下来就是指令集可以帮助CPU更高效地运行。 ARM处理器 上面没有提到的armv6｜armv7｜armv7s｜arm64就属于ARM处理器的指令集。 ARM处理器是英国Acorn有限公司设计的低功耗成本的第一款RISC微处理器。全称为Acorn RISC Machine。ARM处理器本身是32位设计，但也配备16位指令集，一般来讲比等价32位代码节省达35%，却能保留32位系统的所有优势。 ARM处理器主要有这几个特点: 体积小、低功耗、低成本、高性能 支持Thumb（16位）/ARM（32位）双指令集，能很好的兼容8位/16位器件 大量使用寄存器，指令执行速度更快 大多数数据操作都在寄存器中完成 寻址方式灵活简单，执行效率高 指令长度固定 因此几乎所有手机处理器都基于ARM,当然我们使用的iPhone系列手机就是使用的ARM处理器,也就是为什么我们xcode中要配置应用使用的指令集。 armv6｜armv7｜armv7s｜arm64都是ARM处理器的指令集,这些指令集都是向下兼容的，例如armv7指令集兼容armv6，只是使用armv6的时候无法发挥出其性能，无法使用armv7的新特性，从而会导致程序执行效率没那么高。 那么i386 | x86_64又是干嘛用的呢? i386:是针对intel通用微处理器32架构的 x86_64:是针对x86架构的64位处理器 我们在mac上运行模拟器,由于模拟器没有指令集,它使用的是mac的处理器,所以i386｜x86_64 是Mac处理器的指令集。 iOS设备所使用的指令集 指令集 设备型号 arm64 iPhone7,iPhone6s,iphone6s plus,iPhone6,iPhone6 plus,iPhone5S,iPad Air,iPad mini2(iPad mini with Retina Display) armv7s iPhone5,iPhone5C,iPad4(iPad with Retina Display) armv7 iPhone4,iPhone4S,iPad,iPad2,iPad3(The New iPad),iPad mini,iPod Touch 3G,iPod Touch4 armv6 iPhone, iPhone2, iPhone3G, 第一代、第二代 iPod Touch（一般不需要去支持） 指令集相关选项说明 打开xcode-&gt;Buiding Setting-&gt;Architectures可以对应用支持的指令集进行配置。 Architectures 指定工程被编译成可支持哪些指令集类型，而支持的指令集越多，就会编译出包含多个指令集代码的数据包，对应生成二进制包就越大，也就是ipa包会变大。 Valid Architectures 限制可能被支持的指令集的范围，也就是Xcode编译出来的二进制包类型最终从这些类型产生，而编译出支持哪种指令集的包，将由Architectures与Valid Architectures的交集来确定。 比如Architectures设置为arm64 | armv7s | armv7,Valid Architectures设置为arm64 | armv7s,那么它最终生成的二进制包只支持armv7s指令集。 Build Active Architecture Only 设置是否只对当前连接设备所支持的指令集进行编译。当为YES时,只对当前连接设备所支持的指令集进行编译。当为NO时,会编译所有支持的指令集。 一般为了在debug环境能够编译的速度加快,可以设置为NO,当要release的时候设置为YES来适配不同的设备。 总结 armv7s,armv7打包出来的代码是32位的,arm64打包出来的代码64位的。 iPhone5s以前的机型(不包含5s)的cpu是32位的,之后的机型都是64位的。 设备会择优去选择更匹配的包,比如当工程配置为armv7,arm64,则包中会包含32位和64位两份代码,那么在iPhone5s设备下安装,会首选64位的代码包。 若工程配置为armv7打包出来的包是32位的,iPhone5s安装也会兼容,但是会降低性能。 支持arm64的系统版本最低为iOS6,如果要兼容更低版本的系统,需要配置armv7 | armv7s生成32位的包来适配。 我们在开发SDK打包成.a或.framework提供给他人用时,最好做到最大化的兼容,ValidArchitectures设置为：armv7｜armv7s｜arm64｜i386｜x86_64 Architectures设置为(可根据需要调整): armv7｜arm64。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://leonzlw.github.io/tags/iOS/"}]},{"title":"本地自动化Code Review集成","slug":"OCLint","date":"2016-06-25T03:34:36.000Z","updated":"2018-02-05T19:33:12.000Z","comments":true,"path":"2016/06/25/OCLint/","link":"","permalink":"http://leonzlw.github.io/2016/06/25/OCLint/","excerpt":"在项目开工之前,为了保证代码质量,通常我们会和团队中的成员讨论并制定一份代码规范文档,虽然文档已经形成了,但是在实际开发的过程中为了赶项目亦或者某个成员习惯于自己以前的代码风格忽略了规范文档中的细节要求,导致了部分代码风格不统一,这时候再通过审视写过的代码来排查是一件枯燥又乏味的过程,相信大多数紧张进行中的团队也没有足够的时间来做这样一件事情,如果我们能够像xcode编译工程代码一样Command + B就能提示哪里没有符合代码规范就省去了我们大量的Code Review时间,既然本篇文章讲的是自动化Code Review,接下来我们实现这一自动化过程。 OCLint OCLint 是一个开源的，基于 Clang 用 C++ 编写而成的，可以用于 C、C++ 和 Objective-C 的静态代码分析器。它可以在扫描的过程中动态加载规则文件（Rules），因此可以实现非常灵活的，高度可自定义的代码分析方案。它几乎可以和大多数系统无缝集成，例如 Cmake、Bear、xcodebuild、xctool、Xcode、xcpretty、Jenkins CI、Travis CI 等。","text":"在项目开工之前,为了保证代码质量,通常我们会和团队中的成员讨论并制定一份代码规范文档,虽然文档已经形成了,但是在实际开发的过程中为了赶项目亦或者某个成员习惯于自己以前的代码风格忽略了规范文档中的细节要求,导致了部分代码风格不统一,这时候再通过审视写过的代码来排查是一件枯燥又乏味的过程,相信大多数紧张进行中的团队也没有足够的时间来做这样一件事情,如果我们能够像xcode编译工程代码一样Command + B就能提示哪里没有符合代码规范就省去了我们大量的Code Review时间,既然本篇文章讲的是自动化Code Review,接下来我们实现这一自动化过程。 OCLint OCLint 是一个开源的，基于 Clang 用 C++ 编写而成的，可以用于 C、C++ 和 Objective-C 的静态代码分析器。它可以在扫描的过程中动态加载规则文件（Rules），因此可以实现非常灵活的，高度可自定义的代码分析方案。它几乎可以和大多数系统无缝集成，例如 Cmake、Bear、xcodebuild、xctool、Xcode、xcpretty、Jenkins CI、Travis CI 等。 最新版的OCLint已经自带了71条Rules,这些都是先人宝贵的经验,我们可以选择性的去选择规则,也可以去开发自己的Rules。 OCLint 提供了 Clang 和 AST (Abstract Syntax Tree) 的一层封装，使我们不必对抽象语法树进行解析，只需要专注规则相关的逻辑开发即可。在开发好相关的规则后，打包成 dylib，就可以在分析的时候加载我们自己的 Rule 了。 安装OCLint 1.使用Homebrew安装,首先需要设置brew的第三方仓库oclint/formulae。 1brew tap oclint/formulae 2.安装OCLint 1brew install oclint 3.对oclint升级的方法 1brew updatebrew upgrade oclint 4.brew清理旧版本的数据 1brew cleanup 分析自动化Code Review过程 Command + B之后xcode开始编译 + 运行脚本 生成compile_commands.json文件 OCLint读取Rules,逐个扫描compile_commands.json文件中的.m文件 OCLint将生成的报告展示在xcode上。 从上面的过程可以看出首先我们要有一个compile_commands.json的文件,它是 Clang 定义的一个规范，里面存放了一组工作目录、目标文件、需要被执行的命令，帮助相关工具可以独立于编译系统来将源代码文件转换为 AST 并做对应的事。 了解compile_commands.json的地位后我们就生一个出来玩玩! 首先,进入到项目所在目录利用xcodebuild 生成 xcodebuild.log 文件。 1xcodebuild | tee xcodebuild.log 然后使用 oclint-xcodebuild 生成 compile_commands.json 1oclint-xcodebuild 最后在当前目录发现compile_commands.json生成了(是个闺女[偷笑]),但是终端控制器中却显示了这样一段话 12This binary is no longer under maintenance by OCLint team.Please consider using xcpretty (https://github.com/supermarin/xcpretty) instead! 原来OCLint团队将不再维护oclint-xcodebuild,并告诉我们使用xcpretty来替代,好吧,动手再生一个! xcpretty xcpretty是用来格式化xcodebuild输出的工具，使用ruby开发。 安装 1gem install xcpretty 安装后可以通过gem list 来查看列表中有无xcpretty,或者xcpretty –version 来查看版本,如果有xcpretty的相关信息的话恭喜你安装成功了! 使用xcpretty生成compile_commands.json 1xcodebuild |xcpretty -r json-compilation-database 在build/reports中得到文件compilation_db.json,我们发现新生成的compilation_db.json名字和compile_commands.json是有区别的,当我们使用oclint-json-compilation-database对其分析的时候发现找不到文件,报如下错误: 12» oclint-json-compilation-database -- -o=report.htmlError: compile_commands.json not found at current location. 这时候要么我们把build/reports中的compilation_db.json文件复制一份到当前目录并重命名为compile_commands.json,或者我们在使用xcpretty生成.json文件的时候在后面加上导出路径并命名.json文件: –output ./compile_commands.json 1xcodebuild | xcpretty -r json-compilation-database --output ./compile_commands.json 然后再运行 1oclint-json-compilation-database -- -o=report.html 生成最终的报告report.html,打开报告就可以看到哪些代码是不符合规范的了。 我们项目中经常会用到cocopods来管理第三方库,第三方库的代码我们是不需要检查的,可以使用-e来忽略不需要分析的目录 1oclint-json-compilation-database -e Pods -- -o=report.html 如果想改变规则的默认值,使用-rc来修改,比如:变量名的最长字节限制为200 1oclint-json-compilation-database -- -rc=LONG_VARIABLE_NAME=200 -o=report.html 如果想禁止某一个规则的使用可以使用命令-disable-rule 1oclint-json-compilation-database -disable-rule=LongLine 具体都有哪些规则可以查看Rules index,还有OCLint的更多命令说明。 最后我们把下面的脚本集成到xcode工程,实现xcode中command + B 编译提示不符合规范的代码警告 12345678910111213141516171819202122232425262728#! /bin/shif which oclint 2&gt;/dev/null; thenecho &apos;oclint exist&apos;elsebrew tap oclint/formulaebrew install oclintfiif which xcpretty 2&gt;/dev/null; thenecho &apos;xcpretty exist&apos;elsegem install xcprettyfisource ~/.bash_profilecd $&#123;SRCROOT&#125;xcodebuild cleanxcodebuild | xcpretty -r json-compilation-databasecp build/reports/compilation_db.json compile_commands.jsonoclint-json-compilation-database \\-e Pods \\-- \\-disable-rule=IvarAssignmentOutsideAccessorsOrInit \\-disable-rule=HighCyclomaticComplexity \\-disable-rule=UnusedMethodParameter \\-disable-rule=AssignIvarOutsideAccessors \\-max-priority-1=100000 \\-max-priority-2=100000 \\-max-priority-3=100000 \\-report-type xcode 悲剧~结果报错了!错误如下所示: 发现压根没有生成reports文件夹,所以导致compilation_db.json找不到,也就无法copy到当前目录了,查阅了各种资料,而然并没有找到相关问题,终端命令是可以生成compile_commands.json文件的,脚本在xcode中跑就无法生成了- -,哪位朋友如果知道原因的话还请告知一下。 这样不行,我们又想在xcode中查看结果报告,在无法跨越前面的坎儿的情况下只能另辟蹊径了。既然是找不到compile_commands.json文件就报错的,那么我们就先用终端命令在当前目录生成compile_commands.json文件,然后再编译一下,激动人心的时刻——成功了! 如果你的代码不符合规范的话就会报诸如这样的警告⚠️: 从警告可以看出是不符合Size规则中的LongLine规范,我们可以打开Rules查看具体不符合哪一条规则: Issues 可能一路操作过来并不是很顺利,会遇到各种各样的问题,比如下面这样的错误: 12345678910111213141516171819202122Running OCLint....20 errors generated.21 errors generated.1 error generated.1 error generated.24 errors generated.1 error generated.1 error generated.1 error generated.3 errors generated.1 error generated.2 errors generated.1 error generated.32 errors generated.1 error generated.1 error generated.20 errors generated.21 errors generated.1 error generated.1 error generated.24 errors generated.1 error generated.... 我也遇到过上面的报错,不过我是升级了一下oclint就解决了的,如果解决不了的话可以参考一下这里,里面有很多issues以及解决办法,希望可以帮助到你^ ^ 既然有本地Code Review那么肯定也会有远端Code Review了,二者的区别在于本地Review主要是给开发者一个及时的代码质量反馈,远端Review主要是生成报表给各位管理者看的。由于目前还未用到远端Code Review,所以还没有开展这方面的实践,后续还是会把这块空缺补上滴。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://leonzlw.github.io/tags/iOS/"}]},{"title":"AppleDoc自动生成文档","slug":"AppleDoc","date":"2016-06-20T07:23:35.000Z","updated":"2017-02-21T02:44:25.000Z","comments":true,"path":"2016/06/20/AppleDoc/","link":"","permalink":"http://leonzlw.github.io/2016/06/20/AppleDoc/","excerpt":"当项目不断扩大,团队中不断有新的成员加入,这时候就需要我们的项目有可查看的技术文档,方便新加入的成员查阅,快速地了解项目。但是这种文档如果从团队中专门调配出人去整理的话,既低效成本又高,还好iOS也有类似于java语言中的javadoc可以根据源码中的注释来生成技术文档的工具。 目前iOS比较常用的自动生成文档工具有doxygen, headdoc 和 appledoc三个,下面来看一下这三个工具的对比情况。 Doxygen Doxygen原本是为C++开发的文档生成工具，当然它是开源的，通过一票扩展也能支持各种主流非主流语言。除了能生成HTML外，还能生成pdf和LATEXLATEX格式。在appledoc出现之前，很多人就喜欢用这个来生成ObjC代码的文档。相比HeaderDoc来说，有很多可以调教的地方。苹果官方也曾为这个工具写过文档。一切看上去都很棒，不足的地方就是，它生成的文档风格和官方文档的风格差了很多（虽然说不算太难看，但是放到Xcode里看格格不入），配置复杂等。。","text":"当项目不断扩大,团队中不断有新的成员加入,这时候就需要我们的项目有可查看的技术文档,方便新加入的成员查阅,快速地了解项目。但是这种文档如果从团队中专门调配出人去整理的话,既低效成本又高,还好iOS也有类似于java语言中的javadoc可以根据源码中的注释来生成技术文档的工具。 目前iOS比较常用的自动生成文档工具有doxygen, headdoc 和 appledoc三个,下面来看一下这三个工具的对比情况。 Doxygen Doxygen原本是为C++开发的文档生成工具，当然它是开源的，通过一票扩展也能支持各种主流非主流语言。除了能生成HTML外，还能生成pdf和LATEXLATEX格式。在appledoc出现之前，很多人就喜欢用这个来生成ObjC代码的文档。相比HeaderDoc来说，有很多可以调教的地方。苹果官方也曾为这个工具写过文档。一切看上去都很棒，不足的地方就是，它生成的文档风格和官方文档的风格差了很多（虽然说不算太难看，但是放到Xcode里看格格不入），配置复杂等。。 HeaderDoc HeaderDoc是苹果官方的文档生成工具。支持JavaDoc风格的注释，支持一些比较常见的语言，例如Java、C/C++、ObjC、Python、Ruby等等。 官方的好处就是：安好Xcode就自带了，生成的文档风格和Apple官方保持一致，支持语言较多。缺点就是可调教的的地方较少，不生成聚合页，注释风格要求较严等。 appledoc appledoc是最年轻的一个，并且只为Objective-C服务（很专一），能生成和Apple一个风格的文档，功能齐全，使用方便，还可以直接编译成docset安装进xcode。。看样子除了语言支持太少，其他的表现都不错，关键是最贴合Xcode。 虽然没有统计数据，但我相信ObjC这个用的人应该是最多的。 因为我们的项目是基于object-c去开发的,所以经过上面的对比,我更加青睐appledoc,接下来就让我们用appledoc来生成一份文档吧。 安装appledoc 方法一 终端命令 123git clone git://github.com/tomaz/appledoc.gitcd appledocsudo sh install-appledoc.sh 方法二 安装Homebrew 执行命令: brew install appledoc 验证是否安装: 1appledoc --version 如果显示了版本号说明安装成功了,接下来就是用appledoc来生成文档了。 生成API文档 我们新建一个工程,在viewController中的.h中生成注释来测试。既然我们使用的appledoc来生成API文档,那么注释方面也要符合appledoc的注释规范: /// 这是单行注释。 (// 双斜杠这种单行注释是不会被识别的,在xcode中三斜杠的注释 按住option + function 会显示注释内容,双斜杠也是不会显示的) /* 这也是单行注释 / /! 同样是单行注释 / /** 这也是单行注释， 第二行会接上第一行。*/ 在注释块内，appledoc还支持Markdown、HTML、HeaderDoc Tags的语法。 比如我们在viewController.h中的注释是这个样子: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** 第一行是类的简介 在简介的下面,就是类的详细介绍了。 没有间隔换行会被消除，就像Html那样。 下面是常用的markdown语法 - - - 无序列表: (每行以 &apos;*&apos;、&apos;-&apos;、&apos;+&apos; 开头): * this is the first line * this is the second line * this is the third line 有序列表: (每行以 1.2.3、a.b.c 开头): a. this is the first line b. this is the secode line 多级列表: * this is the first line a. this is line a b. this is line b * this is the second line 1. this in line 1 2. this is line 2 标题: # This is an H1 ## This is an H2 ### This is an H3 #### This is an h4 ##### This is an h5 ###### This is an H6 链接: 普通URL直接写上，appledoc会自动翻译成链接: http://leonzlw.github.io/ [这个](http://example.net/) 链接会隐藏实际URL. 表格: | header1 | header2 | header3 | |---------|:-------:|--------:| | normal | center | right | | cell | cell | cell | @since iOS5.0 */@interface ViewController : UIViewController/// 这是属性说明@property (nonatomic, copy) NSString *vcProperty;/** 这里是方法的使用说明,相当于(@discussion) @brief 这里是方法的简介。该Tag不能放到类注释里。 @see initWithTitle: 用它来指明其他相关的 method 或 function。 @param title 参数说明 @return 返回参数说明 */- (instancetype)initWithTitle:(NSString *)title;@end 接下来我们来生成如上所示的文档,有两种方式: 方法一 终端命令生成:进入项目的所在目录,然后运行下面的命令 1appledoc --project-name 工程名称 --project-company 公司名称 --company-id 项目唯一标识 --output 生成结果输出路径 ./ 扫描哪个路径下的类(这里是当前目录下的所有类,包含子目录中的类) 最终会在output的目录中生成docset-installed.txt的文件,打开文件会有如下内容 1234Documentation set was installed to Xcode!Path: /Users/用户名/Library/Developer/Shared/Documentation/DocSets/com.baidu.appledoc.AppleDoc.docsetTime: 2016-08-12 16:48:08 +0000 然后进入Path路径可以发现这个路径是官方API文档的下载目录,我们自己生成的API文档也在这里 .docset其实是一个bundle文件,我们选中自己生成的.docset文件显示包内容可以在Documents目录下看到.html文件。 打开.html文件就可以查阅我们生成的API文档啦~ 方法二 集成到xcode工程:1.新建Aggregate Target 2.添加脚本功能 3.把下面代码中company,companyID,companyURL,outputPath的值替换成你的信息 123456789101112131415161718192021222324252627#appledoc Xcode script # Start constants company=&quot;公司名称&quot;; companyID=&quot;公司id&quot;;companyURL=&quot;公司网址&quot;;target=&quot;iphoneos&quot;;#target=&quot;macosx&quot;;outputPath=&quot;导出路径&quot;;# End constants/usr/local/bin/appledoc \\--project-name &quot;$&#123;PROJECT_NAME&#125;&quot; \\--project-company &quot;$&#123;company&#125;&quot; \\--company-id &quot;$&#123;companyID&#125;&quot; \\--docset-atom-filename &quot;$&#123;company&#125;.atom&quot; \\--docset-feed-url &quot;$&#123;companyURL&#125;/$&#123;company&#125;/%DOCSETATOMFILENAME&quot; \\--docset-package-url &quot;$&#123;companyURL&#125;/$&#123;company&#125;/%DOCSETPACKAGEFILENAME&quot; \\--docset-fallback-url &quot;$&#123;companyURL&#125;/$&#123;company&#125;&quot; \\--output &quot;$&#123;outputPath&#125;&quot; \\--publish-docset \\--docset-platform-family &quot;$&#123;target&#125;&quot; \\--logformat xcode \\--keep-intermediate-files \\--no-repeat-first-par \\--no-warn-invalid-crossref \\--exit-threshold 2 \\#下面是扫描类的路径&quot;$&#123;PROJECT_DIR&#125;&quot; 4.把修改后的脚本代码粘贴到下面的区域 5.xcode工程选中新生成的Target运行就会在outputPath路径中生成你的API文档了,在/Users/用户名/Library/Developer/Shared/Documentation/DocSets/ 中也会生成一份.docset文件。 除了通过.html文件查看API文档也可以通过Dash查看,非常方便哦~ 参考: http://blog.devtang.com/2012/02/01/use-appledoc-to-generate-xcode-doc/ http://blog.ibireme.com/2013/08/26/appledoc-guide/","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://leonzlw.github.io/tags/iOS/"}]},{"title":"解决NSTimer内存泄露的巧妙方式","slug":"NSTimer2","date":"2016-06-05T13:49:43.000Z","updated":"2017-03-20T09:59:28.000Z","comments":true,"path":"2016/06/05/NSTimer2/","link":"","permalink":"http://leonzlw.github.io/2016/06/05/NSTimer2/","excerpt":"在使用NSTimer的过程中可能会遇到控制器明明销毁了,但是就是不会走控制器的dealloc销毁方法,NSTimer也没有停止运行,这就说明在使用NSTimer过程中出现了循环引用导致的内存泄露问题,在stackoverflow上看到了一种巧妙的方式解除这种循环引用,在此记录一下。 发生内存泄漏的场景例如我们在viewController中声明了NSTimer属性,然后在viewDidLoad中去创建一个NSTimer实例赋值给myTimer,让它在dealloc方法中对myTimer进行销毁操作(我们只考虑在dealloc方法中对其销毁): 123456789101112131415161718@interface ViewController ()@property (nonatomic, weak) NSTimer *myTimer;@end- (void)dealloc &#123; [_myTimer invalidate];&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; self.myTimer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(logTime:) userInfo:@&quot;打印log&quot; repeats:YES]; &#125;- (void)logTime:(NSTimer *)timer &#123; NSLog(@&quot;%@&quot;, timer.userInfo);&#125;","text":"在使用NSTimer的过程中可能会遇到控制器明明销毁了,但是就是不会走控制器的dealloc销毁方法,NSTimer也没有停止运行,这就说明在使用NSTimer过程中出现了循环引用导致的内存泄露问题,在stackoverflow上看到了一种巧妙的方式解除这种循环引用,在此记录一下。 发生内存泄漏的场景例如我们在viewController中声明了NSTimer属性,然后在viewDidLoad中去创建一个NSTimer实例赋值给myTimer,让它在dealloc方法中对myTimer进行销毁操作(我们只考虑在dealloc方法中对其销毁): 123456789101112131415161718@interface ViewController ()@property (nonatomic, weak) NSTimer *myTimer;@end- (void)dealloc &#123; [_myTimer invalidate];&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; self.myTimer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(logTime:) userInfo:@&quot;打印log&quot; repeats:YES]; &#125;- (void)logTime:(NSTimer *)timer &#123; NSLog(@&quot;%@&quot;, timer.userInfo);&#125; 这个viewController控制器是我从其他控制器push过来的,这时候我又pop到上一个页面,按道理说viewController应该在这个时候会走dealloc销毁方法对_myTimer进行销毁操作,然后并没有,结合上篇对NSTimer的介绍,分析原因如下: 当前线程RunLoop对NSTimer对象强引用 NSTimer又对self强引用 这样就造成了控制器(self)如果想要销毁的话,NSTimer就要先调用invalidate来销毁 但是控制器(self)不销毁的话 这就产生了一个死循环,谁也释放不掉 到这里会让我们理所当然地想到用__weak来避免循环引用: 12__weak typeof(self) weakSelf = self;self.myTimer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:weakSelf selector:@selector(logTime:) userInfo:@&quot;111&quot; repeats:YES]; 结果还是没有避免循环引用的问题,stackoverflow的回答有这样一段话: It won’t have the effect of creating an NSTimer with a weak reference. The only difference between that code and using a __strong reference is that if self is deallocated in between the two lines given then you’ll pass nil to the timer. 意思是说 weak 和 strong 唯一的区别就是：如果在这两行代码执行的期间 self 被释放了， NSTimer 的 target 会变成 nil。我们用下面这段代码来理解一下这里用__weak修饰是神马意思: 12345__weak typeof(self) weakSelf = self; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; weakSelf.myTimer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:weakSelf selector:@selector(logTime:) userInfo:@&quot;111&quot; repeats:YES]; &#125;); 我们让NSTimer添加的代码延后2s执行,进入到这个控制器后立即(2s内)pop出控制器,然后在block中打断点打印self,这时候self是空的,NSTimer的target也就自然而然是nil。 解决办法想解决这个问题,其实就是想办法让NSTimer不强引用self,那么我们可以创建一个中间对象来替代self,让NSTimer的target强引用这个中间对象,具体实现步骤如下: 定义一个LEOTimerTarget中间类,它的实例对象专门用来取代当前控制器(self)。 然后我们为LEOTimerTarget类定义target和selector属性,这两个属性是用来存放目标对象(这里是控制器)和要执行的目标方法(这里指控制器中的方法)。 然后在NSTimer重复执行任务的方法中判断LEOTimerTarget实例对象的target是否为空,为空的话说明目标对象(这里指当前控制器)已经销毁,接着让NSTimer实例调用invalidate销毁,如果不为空,就通过performSelector:withObject:让目标对象去执行目标方法。 代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@interface LEOTimerTarget : NSObject// 目标对象@property (nonatomic,weak) id target;// 目标方法@property (nonatomic,assign) SEL selector;// NSTimer实例@property (nonatomic, weak) NSTimer *timer;@end@implementation LEOTimerTarget- (void)fire:(NSTimer *)timer &#123; // target为弱引用,所以当target对象销毁时,target 为nil if (self.target) &#123;#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot; [self.target performSelector:self.selector withObject:timer.userInfo];#pragma clang diagnostic pop &#125;else &#123; [timer invalidate]; &#125;&#125;@end// 注意这里不是LEOTimerTarget类@implementation LEOTimer+ (NSTimer *)scheduleTimerWithTimerInterval:(NSTimeInterval)interval target:(id)aTarget selector:(SEL)aSelector userInfo:(id)userInfo repeats:(BOOL)repeats &#123; LEOTimerTarget *leoTimerTarget = [[LEOTimerTarget alloc]init]; leoTimerTarget.target = aTarget; leoTimerTarget.selector = aSelector; leoTimerTarget.timer = [NSTimer scheduledTimerWithTimeInterval:interval target:leoTimerTarget selector:@selector(fire:) userInfo:userInfo repeats:repeats]; return leoTimerTarget.timer;&#125;@end 这样,我们就避免了循环引用的问题,而且无需重复去写NSTimer的销毁方法invalidate。 如果更习惯block调用方式的话,我们也可以在其基础上添加一个block调用接口: 1234567891011121314151617181920+ (NSTimer *)scheduleTimerWithTimerInterval:(NSTimeInterval)interval blockHandle:(LEOTimerBlockHandle)block userInfo:(id)userInfo repeats:(BOOL)repeats &#123; // 这里的self指的是LEOTimer类,它调用的是类方法timerBlockInvoke: return [self scheduleTimerWithTimerInterval:interval target:self selector:@selector(timerBlockInvoke:) userInfo:@[[block copy],userInfo] repeats:repeats];&#125;+ (void)timerBlockInvoke:(NSArray *)userInfo &#123; LEOTimerBlockHandle block = userInfo[0]; id info = userInfo[1]; if (block) &#123; block(info); &#125;&#125; 但是这种block调用方式需要我们在获取NSTimer实例对象后,在合适的位置通过调用invalidate去销毁。 参考: http://stackoverflow.com/questions/16821736/weak-reference-to-nstimer-target-to-prevent-retain-cycle","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://leonzlw.github.io/tags/iOS/"}]},{"title":"NSTimer与RunLoop的那些事","slug":"NSTimer","date":"2016-06-02T14:24:37.000Z","updated":"2017-03-19T16:21:23.000Z","comments":true,"path":"2016/06/02/NSTimer/","link":"","permalink":"http://leonzlw.github.io/2016/06/02/NSTimer/","excerpt":"在项目中我们经常会用到定时器(NSTimer)的定时执行任务功能,虽然它的用法很简单内部却暗藏玄机,如果不搞懂它的工作原理很容易埋下许多坑,在这里详细记录一下。 NSTimer &amp; RunLoop首先NSTimer之所以可以定时去执行任务,实质上是被当前的Runloop驱动的,如果没有Runloop那它就不能运作，所以当我们让NSTimer定时处理事情的时候,要记得将NSTimer添加到了当前的Runloop中,Runloop会获取到NSTimer每一个时间间隔的时间,然后依次去执行我们的事件方法。如果不太明白RunLoop运行机制的童鞋,请戳这里。","text":"在项目中我们经常会用到定时器(NSTimer)的定时执行任务功能,虽然它的用法很简单内部却暗藏玄机,如果不搞懂它的工作原理很容易埋下许多坑,在这里详细记录一下。 NSTimer &amp; RunLoop首先NSTimer之所以可以定时去执行任务,实质上是被当前的Runloop驱动的,如果没有Runloop那它就不能运作，所以当我们让NSTimer定时处理事情的时候,要记得将NSTimer添加到了当前的Runloop中,Runloop会获取到NSTimer每一个时间间隔的时间,然后依次去执行我们的事件方法。如果不太明白RunLoop运行机制的童鞋,请戳这里。 有三种方式来初始化NSTimer: scheduledTimerWithTimeInterval:invocation:repeats: 和 scheduledTimerWithTimeInterval:target:selector:userInfo:repeats: timerWithTimeInterval:invocation:repeats: 和 timerWithTimeInterval:target:selector:userInfo:repeats: initWithFireDate:interval:target:selector:userInfo:repeats: 使用1方式去初始化: NSTimer *myTimer = [NSTimer scheduledTimerWithTimeInterval:1.0 repeats:YES block:^(NSTimer * _Nonnull timer) { NSLog(@\"打印log\"); }]; myTimer会被自动被添加到当前的RunLoop中,并默认让它在当前RunLoop中的运作模式(CFRunLoopModeRef)为NSDefaultRunLoopMode(空闲状态)。 使用2,3方式去初始化,NSTimer不会被自动添加到当前的RunLoop中,也就无法执行任务了,所以我们要手动加入: // NSTimer *myTimer = [[NSTimer alloc]initWithFireDate:[NSDate new] interval:1.0 target:self selector:@selector(logTime:) userInfo:@\"打印log\" repeats:YES]; NSTimer *myTimer = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(logTime:) userInfo:@\"打印log\" repeats:YES]; [[NSRunLoop currentRunLoop] addTimer:myTimer forMode:NSDefaultRunLoopMode]; 这样做的话还会存在一个问题:当前页面如果有一个scrollView,在拖动scrollView的时候,只要不松开手,这个定时器就停止执行任务了,松开手后又恢复了正常。出现这个问题的原因还是与RunLoop有关,因为系统默认的RunLoop有两个模式: NSDefaultRunLoopMode:可以理解为空闲模式,就是当屏幕没有做任何操作时的状态。 UITrackingRunLoopMode:可以理解为滑动模式,就是当处理手势或者滑动操作时的状态。 因为NSTimer默认是添加到NSDefaultRunLoopMode模式下的,所以当屏幕处于空闲期时,当前线程的RunLoop在NSDefaultRunLoopMode模式下工作,当滑动屏幕内容后,当前线程的RunLoop就会自动切换到UITrackingRunLoopMode模式下工作,那么NSTimer也就不执行了。 解决办法: 再添加一个UITrackingRunLoopMode 1[[NSRunLoop currentRunLoop] addTimer:myTimer [[NSRunLoop currentRunLoop] addTimer:myTimer forMode:NSDefaultRunLoopMode]; 把NSTimer添加到NSRunLoopCommonModes模式(NSRunLoopCommonModes默认包含:NSDefaultRunLoopMode和UITrackingRunLoopMode)。 1[[NSRunLoop currentRunLoop] addTimer:myTimer forMode:NSRunLoopCommonModes]; 以上都是在主线程的操作的,如果我们让它在子线程执行: dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ NSTimer *myTimer = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(logTime:) userInfo:@\"打印log\" repeats:YES]; [[NSRunLoop currentRunLoop] addTimer:myTimer forMode:UITrackingRunLoopMode]; [[NSRunLoop currentRunLoop] addTimer:myTimer forMode:NSDefaultRunLoopMode]; }); 发现又不执行了-_-||,这是为毛呢?还是和RunLoop有关!到底多大仇!!! 这里要说明一点:线程和RunLoop是一一对应的,但是各子线程中的RunLoop是要通过CoreFoundation框架中的CFRunLoopGetCurrent()函数来获取,主线程通过CFRunLoopGetMain()来获取,最后通过CFRunLoopRun()来开启RunLoop。主线程默认就是开启的状态,所以我们只需要将NSTimer添加到主线程的RunLoop就可以起到效果,但是在子线程中我们还要通过调用CFRunLoopRun()函数使其run起来! dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ NSTimer *myTimer = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(logTime:) userInfo:@\"打印log\" repeats:YES]; [[NSRunLoop currentRunLoop] addTimer:myTimer forMode:UITrackingRunLoopMode]; [[NSRunLoop currentRunLoop] addTimer:myTimer forMode:NSDefaultRunLoopMode]; [[NSRunLoop currentRunLoop] run]; }); 另外文档中有这样一个提示: Note in particular that run loops maintain strong references to their timers, so you don’t have to maintain your own strong reference to a timer after you have added it to a run loop. 说的是NSTimer实例会被当前线程的RunLoop强引用,所以在使用时不需要把NSTimer声明成强引用类型的属性或成员变量。 想了解线程与RunLoop之间关系的请看下面的源码整理: 1234567891011121314151617181920212223242526272829303132333435363738/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRefstatic CFMutableDictionaryRef loopsDic;/// 访问 loopsDic 时的锁static CFSpinLock_t loopsLock; /// 获取一个 pthread 对应的 RunLoop。CFRunLoopRef _CFRunLoopGet(pthread_t thread) &#123; OSSpinLockLock(&amp;loopsLock); if (!loopsDic) &#123; // 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。 loopsDic = CFDictionaryCreateMutable(); CFRunLoopRef mainLoop = _CFRunLoopCreate(); CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop); &#125; /// 直接从 Dictionary 里获取。 CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread)); if (!loop) &#123; /// 取不到时，创建一个 loop = _CFRunLoopCreate(); CFDictionarySetValue(loopsDic, thread, loop); /// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。 _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop); &#125; OSSpinLockUnLock(&amp;loopsLock); return loop;&#125; CFRunLoopRef CFRunLoopGetMain() &#123; return _CFRunLoopGet(pthread_main_thread_np());&#125; CFRunLoopRef CFRunLoopGetCurrent() &#123; return _CFRunLoopGet(pthread_self());&#125; NSTimer触发时间 A timer is not a real-time mechanism; it fires only when one of the run loop modes to which the timer has been added is running and able to check if the timer’s firing time has passed. Because of the various input sources a typical run loop manages, the effective resolution of the time interval for a timer is limited to on the order of 50-100 milliseconds. If a timer’s firing time occurs during a long callout or while the run loop is in a mode that is not monitoring the timer, the timer does not fire until the next time the run loop checks the timer. Therefore, the actual time at which the timer fires potentially can be a significant period of time after the scheduled firing time.e. 通过官网文档描述可以了解到NSTimer并不是实时触发的,主要会受这两种情况影响: 当NSTimer处于一种runloopMode中,当Mode发生变化的时候(例如:NSDefaultRunLoopMode 切换到 UITrackingRunLoopMode模式)。 当NSTimer所在线程正在执行耗时任务的时候,定时任务会延时。 另外官方文档有引入Timer Tolerance(时间容差值)这个概念: In iOS 7 and later and macOS 10.9 and later, you can specify a tolerance for a timer (tolerance). Allowing the system flexibility in when a timer fires improves the ability of the system to optimize for increased power savings and responsiveness. 意思是说tolerance是用来节省电量和优化系统响应速度的。 如果设置了这个容差值,那NSTimer的启动时间又是什么时候?请继续看官方文档的解释: The timer may fire at any time between its scheduled fire date and the scheduled fire date plus the tolerance. The timer will not fire before the scheduled fire date. NStimer真实启动时间会在我们 设定的时间 和 设定的时间+容差值 之间(设定时间 &lt;= NSTimer的启动时间 &lt;= 设定时间 + tolerance)。 The default value is zero, which means no additional tolerance is applied. The system reserves the right to apply a small amount of tolerance to certain timers regardless of the value of the tolerance property.Even a small amount of tolerance will have a significant positive impact on the power usage of your application. tolerance默认为0,但也不意味着我们的定时器能够按精准的时间来执行,系统会为它设置一个非常小的容差值,即使是极小的容差值也能大大节省你应用的耗电情况。 NSTimer销毁 Once scheduled on a run loop, the timer fires at the specified interval until it is invalidated. A non-repeating timer invalidates itself immediately after it fires. However, for a repeating timer, you must invalidate the timer object yourself by calling its invalidate method. Calling this method requests the removal of the timer from the current run loop; as a result, you should always call the invalidate method from the same thread on which the timer was installed. Invalidating the timer immediately disables it so that it no longer affects the run loop. The run loop then removes the timer (and the strong reference it had to the timer), either just before the invalidate method returns or at some later point. Once invalidated, timer objects cannot be reused. 官方文档里有说到: 当使用non-repeating timer的时候,它的销毁时间会在第一次定时执行任务后,无需我们手动调用invalidate方法。 当使用repeating timer的时候,我们在哪个线程创建的就要在哪个线程去销毁它。 当NSTimer被销毁后,无法再重新被使用。 总结通过上面的代码示例说明和官方文档的描述,我们基本掌握了NSTimer的使用和它的运行机制,下面是对它的总结: NSTimer的创建和销毁都要保证在同一线程下操作(当repeat=YES时,必须要调用invalidate方法销毁)。 NSTimer会被当前线程的RunLoop强引用。 在使用NSTimer时,要把实例添加到当前线程的RunLoop中,并启动RunLoop。 NSTimer的创建和销毁尽量放到子线程去,因为主线程要处理的事情有很多,会影响到定时器的精准度,同时也会给主线程增加负荷。 参考文献: NSTimer API Reference","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://leonzlw.github.io/tags/iOS/"}]},{"title":"制作.bundle文件","slug":"StaticsPackage3","date":"2016-05-10T06:47:24.000Z","updated":"2017-02-21T02:46:39.000Z","comments":true,"path":"2016/05/10/StaticsPackage3/","link":"","permalink":"http://leonzlw.github.io/2016/05/10/StaticsPackage3/","excerpt":"在我们使用第三方框架时经常会看到xxx.bundle的文件,我们找到该文件,右键显示包内容,会看到很多图片,配置文件,.xib等资源文件。在我们SDK打包的过程中,也会将资源文件一并打包成.bundle文件使用,那是为什么呢?其实.bundle文件与我们平时的文件夹并无太大区别,在我看来只是加了后缀罢了,它更像是一个包,如果在工程外部想查看内部的文件需要显示包内容查看,在移动包文件的过程中在一定程度上也降低了他人对包内容误改的几率。 什么是bundle文件? 简单理解，就是资源文件包。我们将许多图片、XIB、文本文件组织在一起，打包成一个Bundle文件。方便在其他项目中引用包内的资源。","text":"在我们使用第三方框架时经常会看到xxx.bundle的文件,我们找到该文件,右键显示包内容,会看到很多图片,配置文件,.xib等资源文件。在我们SDK打包的过程中,也会将资源文件一并打包成.bundle文件使用,那是为什么呢?其实.bundle文件与我们平时的文件夹并无太大区别,在我看来只是加了后缀罢了,它更像是一个包,如果在工程外部想查看内部的文件需要显示包内容查看,在移动包文件的过程中在一定程度上也降低了他人对包内容误改的几率。 什么是bundle文件? 简单理解，就是资源文件包。我们将许多图片、XIB、文本文件组织在一起，打包成一个Bundle文件。方便在其他项目中引用包内的资源。 Bundle文件的特点？ Bundle是静态的，也就是说，我们包含到包中的资源文件作为一个资源包是不参加项目编译的。也就意味着，bundle包中不能包含可执行的文件。它仅仅是作为资源，被解析成为特定的2进制数据。 如何制作.bundle文件? 方式1: 创建一个文件夹 将资源文件放到创建的文件夹中 给文件夹添加.bundle后缀 把.bundle文件拖拽到项目中使用即可 这里需要注意的是:如果资源中包含.xib文件,需要使用命令把xib转化为nib文件: 1$ ibtool --errors --warnings --output-format human-readable-text --compile 文件名.nib 文件名.xib 如果不转换, 读取的时候会导致如下错误: 1234Terminating app due to uncaught exception &apos;NSInternalInconsistencyException&apos;, reason: &apos;Could not load NIB in bundle:&apos;NSBundle &lt;/var/mobile/Applications/C6718DB8-0C0F-4D38-84E6-55C145279957/Documents/asset-4.bundle&gt; (not yet loaded)&apos; with name &apos;file&apos;&apos; 方式2: 1.新建bundle项目 2.添加资源文件 3.因为只有macOS可以创建bundle项目,所以我们需要将build setting中的Base SDK值改成iOS的版本 4.编译工程生成.bundle文件 使用bundle中的资源 由于bundle是静态的,不会进行编译的资源文件,所以要使用bundle中的资源，首先要找到我们生成Bundle文件路径来生成NSBundle实例,然后再使用资源名字从生成的NSBundle实例中找到对应的资源。 获取Bundle中的nib资源文件 123456// 在SecondVC的初始化方法中加载- (instancetype)init &#123; NSBundle *bundle = [[NSBundle alloc]initWithPath:[[NSBundle mainBundle] pathForResource:@&quot;CreateBundle&quot; ofType:@&quot;bundle&quot;]]; self = [super initWithNibName:@&quot;SecondVC&quot; bundle:bundle]; return self;&#125; 或者在需要使用的地方直接使用initWithNibName:bundle:去加载 123NSBundle *bundle = [[NSBundle alloc]initWithPath:[[NSBundle mainBundle] pathForResource:@&quot;CreateBundle&quot; ofType:@&quot;bundle&quot;]]; SecondVC *second = [[SecondVC alloc]initWithNibName:@&quot;SecondVC&quot; bundle:bundle]; [self presentViewController:second animated:YES completion:nil]; 获取Bundle中的图片资源 方法1: 12UIImage *image = [UIImage imageNamed:@&quot;CreateBundle/image1&quot;];UIImageView *imageView = [[UIImageView alloc]initWithImage:image]; 方法2: 1234567// 获取Bundle路径NSString *bundlePath = [[NSBundle mainBundle] pathForResource:@&quot;CreateBundle&quot; ofType:@&quot;bundle&quot;];// 拼接图片资源路径NSString *imgPath= [bundlePath stringByAppendingPathComponent :@&quot;image1.jpeg&quot;];// 路径加载UIImage *image=[UIImage imageWithContentsOfFile:imgPath];UIImageView *imageView = [[UIImageView alloc]initWithImage:image]; 经验分享 如果是bundle文件外部的xib或者StoryBoard要使用图片资源的话,在设置图片的位置要使用 bundle名/资源名 这种样式去加载,与纯代码获取图片资源的方式1一样。如果是bundle文件内部的xib或者storyBoard的话,直接资源名字就可以了。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://leonzlw.github.io/tags/iOS/"}]},{"title":"iOS打包静态库(二)","slug":"StaticsPackage2","date":"2016-05-04T10:31:16.000Z","updated":"2017-02-21T02:44:47.000Z","comments":true,"path":"2016/05/04/StaticsPackage2/","link":"","permalink":"http://leonzlw.github.io/2016/05/04/StaticsPackage2/","excerpt":"上一篇主要是介绍打包.a静态库的一些操作,这一篇主要介绍一下打包.framework流程。在接下来介绍的过程中,相信你也会慢慢体会到.framework和.a在实际应用中的关系是什么,了解了它们的关系后我们会对.framework如何打包成.a和.a如何打包成.framework进行说明,最终决定将你们的项目部分组件或功能模块打包成.framework形式的静态库比较好还是.a形式的静态库比较好由个人喜好而定,区别不大,本人更喜欢使用.framework静态库,相对来说更方便一些,不用再去管那些.h文件应该放在哪里。 第一步,新建打包.framework的项目","text":"上一篇主要是介绍打包.a静态库的一些操作,这一篇主要介绍一下打包.framework流程。在接下来介绍的过程中,相信你也会慢慢体会到.framework和.a在实际应用中的关系是什么,了解了它们的关系后我们会对.framework如何打包成.a和.a如何打包成.framework进行说明,最终决定将你们的项目部分组件或功能模块打包成.framework形式的静态库比较好还是.a形式的静态库比较好由个人喜好而定,区别不大,本人更喜欢使用.framework静态库,相对来说更方便一些,不用再去管那些.h文件应该放在哪里。 第一步,新建打包.framework的项目 第二步,将下载下来的SVProgressHUD文件包拖入工程,并将.bundle文件移除,原因是.bundle文件打包到.framework中,iOS系统并不会去扫描.framework下的.bundle资源文件,与打包.a库一样,.bundle资源文件需要在外部配合使用。 第三步,将需要暴露的.h文件拖拽带public区域 第四部,设置编译模式为Release模式 第五步,build settings 下的Mach-O Type 类型一定要改为 Static Library,因为苹果不支持动态库类型,.framework也属于静态库。 第六步,分别选择真机和模拟器编译一遍,会分别生成Release-iphoneos和Release-iphonesimulator两个文件夹,文件夹下便是我们编译后生成的.framework静态库。 第七步,合并模拟器和真机的.framework静态库下的二进制文件,注意:路径要具体到二进制文件而不是.framework静态库。 1lipo -create /Users/[your user name]/Library/Developer/Xcode/DerivedData/DynamicSVProgressHUD-hhzxauickcqbyyaijmnejkydrnug/Build/Products/Release-iphoneos/DynamicSVProgressHUD.framework/DynamicSVProgressHUD /Users/[your user name]/Library/Developer/Xcode/DerivedData/DynamicSVProgressHUD-hhzxauickcqbyyaijmnejkydrnug/Build/Products/Release-iphonesimulator/DynamicSVProgressHUD.framework/DynamicSVProgressHUD -output /Users/[your user name]/Desktop/DynamicSVProgressHUD/DynamicSVProgressHUD 最后将任意一个.framework下的二进制文件替换成新生成的二进制文件即可。 第八步,我们新建一个新的工程,将我们自己生成.framework静态库拖入工程,对了,别忘了把SVProgressHUD.bundle资源文件也拖入工程,接下来run一下看看效果如下: 经过这两小节的介绍我们可以发现,.framework实质就是.a + .h 组合,.a静态库也需要配合.h文件使用,只不过我们生成.framework的时候,.h已经包含到了.framework静态库里面了,而.a静态库只是一个单独的库,.h文件没有包含进去,需要配合着使用才能发挥作用。 那么,如果我们想要把.framework打包成静态库.a的形式的话,只需要把.framework中的二进制文件和.h文件拖到打包.a静态库的工程中生成新的.a静态库即可。 同理,如果.a静态库想打包成.framework静态库,也只需要把.h和.a文件拖入到打包.framework静态库的工程中生成.framework静态库即可。 打包.a和.framework静态库过程中可能会遇到问题总结 如果创建的framework中使用了category类，则在使用framework的项目配置中【Other Linker Flags】需要添加参数【-ObjC]或者【-all_load】 如果使用framework的使用出现【Umbrella header for module ‘XXXX’ does not include header ‘XXXXX.h’】,是因为错把xxxxx.h拖到了public中。 如果出现【dyld: Library not loaded:XXXXXX】，是因为打包的framework版本太高。比如打包framework时，选择的是iOS 9.0，而实际的工程环境是iOS 8开始的。 如果创建的framework类中使用了.dylib或者.tbd，首先需要在实际项目中导入.dylib或者.tbd动态库，然后需要设置build setting 中的【Allow Non-modular Includes ….】为YES，否则会报错”Include of non-modular header inside framework module”。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://leonzlw.github.io/tags/iOS/"}]},{"title":"iOS打包静态库(一)","slug":"StaticsPackage","date":"2016-04-22T11:06:52.000Z","updated":"2017-02-21T02:44:42.000Z","comments":true,"path":"2016/04/22/StaticsPackage/","link":"","permalink":"http://leonzlw.github.io/2016/04/22/StaticsPackage/","excerpt":"前段时间由于工作的调动，接触到了游戏SDK的开发工作，最终要打包成静态库供游戏商使用,在这里做下记录。 为什么要打包成静态库?举个栗子,比如支付宝,百度地图SDK中,他们仅仅是给我们暴露出来了.h文件中的接口,具体的实现隐藏到了静态库中,因为他们不想让别人拿到自己公司私密性的内容,这就是静态库的作用(使用场景)。 什么是库？库从本质上来说是一种可执行代码的二进制格式，可以被载入内存中执行。库分静态库和动态库两种。iOS中的静态库有 .a 和 .framework两种形式；动态库有.dylib 和 .framework 形式，后来.dylib动态库又被苹果替换成.tbd的形式。 静态库和动态库的介绍 静态库：静态库即静态链接库（Windows下的.lib，Linux 和 Mac 下的.a。之所以叫做静态，是因为静态库在编译的时候会被直接拷贝一份，复制到目标程序里，这段代码在目标程序里就不会再改变了。静态库的好处很明显，编译完成之后，库文件实际上就没有作用了。目标程序没有外部依赖，直接就可以运行。当然其缺点也很明显，就是会使用目标程序的体积增大。","text":"前段时间由于工作的调动，接触到了游戏SDK的开发工作，最终要打包成静态库供游戏商使用,在这里做下记录。 为什么要打包成静态库?举个栗子,比如支付宝,百度地图SDK中,他们仅仅是给我们暴露出来了.h文件中的接口,具体的实现隐藏到了静态库中,因为他们不想让别人拿到自己公司私密性的内容,这就是静态库的作用(使用场景)。 什么是库？库从本质上来说是一种可执行代码的二进制格式，可以被载入内存中执行。库分静态库和动态库两种。iOS中的静态库有 .a 和 .framework两种形式；动态库有.dylib 和 .framework 形式，后来.dylib动态库又被苹果替换成.tbd的形式。 静态库和动态库的介绍 静态库：静态库即静态链接库（Windows下的.lib，Linux 和 Mac 下的.a。之所以叫做静态，是因为静态库在编译的时候会被直接拷贝一份，复制到目标程序里，这段代码在目标程序里就不会再改变了。静态库的好处很明显，编译完成之后，库文件实际上就没有作用了。目标程序没有外部依赖，直接就可以运行。当然其缺点也很明显，就是会使用目标程序的体积增大。 动态库：动态库即动态链接库（Windows 下的 .dll，Linux 下的 .so，Mac 下的 .dylib）。与静态库相反，动态库在编译时并不会被拷贝到目标程序中，目标程序中只会存储指向动态库的引用。等到程序运行时，动态库才会被真正加载进来。动态库的优点是，不需要拷贝到目标程序中，不会影响目标程序的体积，而且同一份库可以被多个程序使用（因为这个原因，动态库也被称作共享库）。同时，编译时才载入的特性，也可以让我们随时对库进行替换，而不需要重新编译代码。动态库带来的问题主要是，动态载入会带来一部分性能损失，使用动态库也会使得程序依赖于外部环境。如果环境缺少动态库或者库的版本不正确，就会导致程序无法运行（Linux 下喜闻乐见的 lib not found 错误）。 iOS里静态库和动态库的存在形式 静态库:.a 和 .framework 动态库:.dylib(.tbd) 和 .framework 静态库与动态库的区别？ 静态库：链接时，静态库会被完整地复制到可执行文件中，被多次使用就有多份冗余拷贝。 动态库：链接时不复制，程序运行时由系统动态加载到内存，供程序调用，系统只加载一次，多个程序共用，节省内存。 .a文件是一个纯二进制文件，至少需要配合.h文件去使用，如果需要资源文件，要在把资源文件放在外部并不能把资源文件一同打包成.a文件。 .framework相当于.a + .h + sourceFile的整合，打包过程中可加入其它.a文件进行一同打包成最终的.framework文件。 (注意:.framwork中将图片资源或.xib 加入到其中也是读取不到的,因为iOS系统不会去扫描.framework下的资源文件。当然,我们可以放入一些说明文件在其中作为说明文件,查看起来还是清晰明了哒。) 实践我们在打包.a文件时可能会遇到这3种情况: 把.h和.m文件打包成.a文件和.h文件。 把.a文件和.h文件打包成新的.a文件和.h文件。 被打包的文件含有.bundle资源文件。 第一种情况直接将.h和.m添加到打包的工程中进行打包即可。第二种情况相当于把.a文件打包成新的.a文件,把.a文件和.h文件一并拖入到打包的工程中进行打包即可。第三种情况.bundle资源文件不参与打包过程,把.a文件和.h文件拖入到打包的工程生成新的.a和.h文件,再匹配.bundle文件使用即可。 举个栗子,我们要把一个包含.bundle文件的第三方库(以SVProgressHUD为例)打包成.a静态库(下面的过程就是打包静态库.a的过程,第1,2种情况按正常流程打包,主要针对第3中情况进行说明.bundle文件为什么不能进行打包): 第一步,先创建一个打包.a静态库的工程: 第二步,把我们下载好的SVProgressHUD文件拖入到工程内: 第三步,如图操作: 第四步,如图操作: 第五步,commad + B 真机编译一下然后再模拟器编译一下,为什么要真机编译呢?因为如果我们不真机编译的话,如第三步图中左下角标注的.a包将始终是红色的,我们将获取不到文件的生成路径,真机编译和模拟器编译会出来两个分别支持真机和模拟器的.a包,如果我们需要.a静态库在真机和模拟器都要支持的话,需要执行 lipo -create /Users/harvey/Library/Developer/Xcode/DerivedData/FMDB-clvayfrjgytqrbdkyqrtcjkxfeuz/Build/Products/Release-iphonesimulator/FMDB.framework/FMDB /Users/harvey/Library/Developer/Xcode/DerivedData/FMDB-clvayfrjgytqrbdkyqrtcjkxfeuz/Build/Products/Release-iphoneos/Release-iphoneos.framework/FMDB -output /Users/harvey/Desktop/FMDB 将它们合并下即可\u0005。因为我只是想在模拟器测试一下,所以就偷懒不合并了^ ^, 编译后查找到.a文件的路径如下:usr文件下是我们暴露出来的.h文件 第六步,我们新建一个测试的工程,将SVProgressHUD.h(我暴露出来的头文件)和libLibraryPackag.a 导入到测试工程: 第七步,在ViewController实现文件导入SVProgressHUD.h头文件,调用它的loading方法 第八步,command + R 运行,发现crash了,看下控制面板: 第九步,知道原因后,我们重新去打包静态库的工程打包一遍,这次我们把第二步中的红框.bundle文件移除掉打包,然后把新打包成功的.a文件 + 刚才移除掉的.bundle文件直接拖入到测试工程内,如图: 第十步,再command + R运行如下: 如果这时候我们需要把libLibraryPackage.a与另一个.a文件进行合并,另一个.a文件比如叫otherlibLibraryPackage.a,这时候我们只需要把libLibraryPackage.a和otherlibLibraryPackage.a添加到打包静态库的工程中打包成一个全新的.a静态库,具体操作重复上述步骤进行就可以了。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://leonzlw.github.io/tags/iOS/"}]},{"title":"NSAttributedString的基本用法和特殊处理","slug":"The-first-techenology-blog","date":"2016-03-22T08:52:49.000Z","updated":"2017-02-21T02:44:56.000Z","comments":true,"path":"2016/03/22/The-first-techenology-blog/","link":"","permalink":"http://leonzlw.github.io/2016/03/22/The-first-techenology-blog/","excerpt":"第一篇技术博客就从最近遇到的一个小问题着手吧,顺便也来复习一下NSAttributedString的基本用法。 NSAttributedStringNSAttributedString叫做富文本，是一种带有属性的字符串，通过它可以轻松的在一个字符串中表现出多种字体、字号、字体大小等各不相同的风格，还可以对段落进行格式化。 富文本分为不可变(NSAttributedString)和可变(NSMutableAttributedString)两种类型,两者的区别在于初始化完成后可变类型可以对其内部的值进行修改操作(即:覆盖,插入,删除字符串等操作), 而不可变类型则反之。由于NSAttributedString类型方法比较局限,我们直接创建继承自它的NSMutableAttributedString类型对象","text":"第一篇技术博客就从最近遇到的一个小问题着手吧,顺便也来复习一下NSAttributedString的基本用法。 NSAttributedStringNSAttributedString叫做富文本，是一种带有属性的字符串，通过它可以轻松的在一个字符串中表现出多种字体、字号、字体大小等各不相同的风格，还可以对段落进行格式化。 富文本分为不可变(NSAttributedString)和可变(NSMutableAttributedString)两种类型,两者的区别在于初始化完成后可变类型可以对其内部的值进行修改操作(即:覆盖,插入,删除字符串等操作), 而不可变类型则反之。由于NSAttributedString类型方法比较局限,我们直接创建继承自它的NSMutableAttributedString类型对象1234567891011121314// 常规初始化方法有三个NSString *str = @&quot;The first Technology blog&quot;;// 1.直接赋值(NSString类型)- (instancetype)initWithString:(NSString *)str;NSMutableAttributedString *mutableAttributeStr1 = [[NSMutableAttributedString alloc]initWithString:str];// 2.赋值并添加文本属性- (instancetype)initWithString:(NSString *)str attributes:(nullable NSDictionary&lt;NSString *, id&gt; *)attrs;NSDictionary *attributesDic = @&#123;NSFontAttributeName : [UIFont systemFontOfSize:20],NSForegroundColorAttributeName : [UIColor blueColor]&#125;;NSMutableAttributedString *mutableAttributeStr2 = [[NSMutableAttributedString alloc]initWithString:str attributes:attributesDic];// 3.直接赋值(NSAttributedString类型)- (instancetype)initWithAttributedString:(NSAttributedString *)attrStr;NSMutableAttributedString *mutableAttributeStr3 = [[NSMutableAttributedString alloc]initWithAttributedString:mutableAttributeStr2]; 第一种初始化时:不能直接设置文本属性第二种初始化时:可以设置文本属性第三种初始化时:直接获取mutableAttributeStr2的文本属性介绍完初始化方法,再来看一看它都有哪些属性: 123456789101112131415161718192021// NSFontAttributeName 设置字体属性，默认值：字体：Helvetica(Neue) 字号：12// NSForegroundColorAttributeNam 设置字体颜色，取值为 UIColor对象，默认值为黑色// NSBackgroundColorAttributeName 设置字体所在区域背景颜色，取值为 UIColor对象，默认值为nil, 透明色// NSLigatureAttributeName 设置连体属性，取值为NSNumber 对象(整数)，0 表示没有连体字符，1 表示使用默认的连体字符// NSKernAttributeName 设定字符间距，取值为 NSNumber 对象（整数），正值间距加宽，负值间距变窄// NSStrikethroughStyleAttributeName 设置删除线，取值为 NSNumber 对象（整数）// NSStrikethroughColorAttributeName 设置删除线颜色，取值为 UIColor 对象，默认值为黑色// NSUnderlineStyleAttributeName 设置下划线，取值为 NSNumber 对象（整数），枚举常量 NSUnderlineStyle中的值，与删除线类似// NSUnderlineColorAttributeName 设置下划线颜色，取值为 UIColor 对象，默认值为黑色// NSStrokeWidthAttributeName 设置笔画宽度，取值为 NSNumber 对象（整数），负值填充效果，正值中空效果// NSStrokeColorAttributeName 填充部分颜色，不是字体颜色，取值为 UIColor 对象// NSShadowAttributeName 设置阴影属性，取值为 NSShadow 对象// NSTextEffectAttributeName 设置文本特殊效果，取值为 NSString 对象，目前只有图版印刷效果可用：// NSBaselineOffsetAttributeName 设置基线偏移值，取值为 NSNumber （float）,正值上偏，负值下偏// NSObliquenessAttributeName 设置字形倾斜度，取值为 NSNumber （float）,正值右倾，负值左倾// NSExpansionAttributeName 设置文本横向拉伸属性，取值为 NSNumber （float）,正值横向拉伸文本，负值横向压缩文本// NSWritingDirectionAttributeName 设置文字书写方向，从左向右书写或者从右向左书写// NSVerticalGlyphFormAttributeName 设置文字排版方向，取值为 NSNumber 对象(整数)，0 表示横排文本，1 表示竖排文本// NSLinkAttributeName 设置链接属性，点击后调用浏览器打开指定URL地址// NSAttachmentAttributeName 设置文本附件,取值为NSTextAttachment对象,常用于文字图片混排// NSParagraphStyleAttributeName 设置文本段落排版格式，取值为 NSParagraphStyle 对象 因为NSAttributedString的属性以字典的形式存在的，所以上面的属性作为key对应后面的value类型 即:@{key : value}形式。富文本属性可以在初始化时直接设置,也可以在其初始化完成之后设置或添加(注意:初始化之后进行属性操作必须是NSMutableAttributedString类型): (void)setAttributes:(nullable NSDictionary *)attrs range:(NSRange)range; (void)addAttribute:(NSString *)name value:(id)value range:(NSRange)range; (void)addAttributes:(NSDictionary *)attrs range:(NSRange)range; 看到这里发现既有set又有add开头的方法, 那么顺便说一下在iOS中以set和add开头的方法的规律: 一般以set开头的方法是赋值操作,会覆盖掉上一次的操作 一般以add开头的方法是添加操作,多次添加一般会累加 注意: 这里的set开头的方法不包括setter方法以addAttribute:value:range:和addAttributes:range:为例:123[mutableAttributeStr1 addAttributes:@&#123;NSFontAttributeName : [UIFont boldSystemFontOfSize:50]&#125; range:NSMakeRange(0, mutableAttributeStr1.length)];[mutableAttributeStr1 addAttribute:NSBackgroundColorAttributeName value:[UIColor redColor] range:NSMakeRange(0, mutableAttributeStr1.length)];//富文本最后的样式为:50号字体 红色背景 再来试一下setAttributes:range:方法: 12345[mutableAttributeStr1 addAttributes:@&#123;NSFontAttributeName : [UIFont boldSystemFontOfSize:50]&#125; range:NSMakeRange(0, mutableAttributeStr1.length)];[mutableAttributeStr1 addAttribute:NSBackgroundColorAttributeName value:[UIColor redColor] range:NSMakeRange(0, mutableAttributeStr1.length)];[mutableAttributeStr1 setAttributes:@&#123;NSFontAttributeName : [UIFont boldSystemFontOfSize:10]&#125; range:NSMakeRange(0, mutableAttributeStr1.length)];// 富文本最后的样式为: 10号字体 而前面设置的红色背景并没有了// 现在区别应该显而易见了^ ^ 忽略上面对mutableAttributeStr1的设置,现在我们为mutableAttributeStr1重新添加文本属性: 1234567891011121314151617[mutableAttributeStr1 addAttributes:@&#123;NSFontAttributeName : [UIFont boldSystemFontOfSize:50], NSBackgroundColorAttributeName : [UIColor yellowColor]&#125; range:NSMakeRange(0, 3)];[mutableAttributeStr1 addAttributes:@&#123;NSFontAttributeName : [UIFont boldSystemFontOfSize:70], NSForegroundColorAttributeName : [UIColor redColor], NSStrikethroughStyleAttributeName : @1&#125; range:NSMakeRange(4, 5)];[mutableAttributeStr1 addAttributes:@&#123;NSFontAttributeName : [UIFont boldSystemFontOfSize:40], NSUnderlineStyleAttributeName : @1, NSUnderlineColorAttributeName : [UIColor purpleColor], NSStrokeWidthAttributeName : @4&#125; range:NSMakeRange(10, 11)];[mutableAttributeStr1 addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:50] range:NSMakeRange(21, 5)];[mutableAttributeStr1 addAttribute:NSObliquenessAttributeName value:@0.3 range:NSMakeRange(21, 5)];NSMutableParagraphStyle *paragraphStyle = [[NSMutableParagraphStyle alloc]init];paragraphStyle.lineSpacing = 170.0;paragraphStyle.firstLineHeadIndent = 30.0;paragraphStyle.headIndent = 100.0;[mutableAttributeStr1 addAttribute:NSParagraphStyleAttributeName value:paragraphStyle range:NSMakeRange(0, mutableAttributeStr1.length)];self.myLabel.attributedText = mutableAttributeStr1; 其它属性效果自行测试,运行效果如下:如果字符串str是一串带有html标签的字符串,我们要使用它的另一个初始化方法-(nullable instancetype)initWithData:(NSData )data options:(NSDictionary&lt;NSString , id&gt; )options documentAttributes:(NSDictionary&lt;NSString , id&gt; __nullable __nullable)dict error:(NSError **)error 123NSString * htmlText = @&quot;&lt;b&gt;The&lt;/b&gt; first &lt;h3&gt;technology&lt;/h3&gt; blog&quot;;NSMutableAttributedString * mutableAttributeStr = [[NSMutableAttributedString alloc] initWithData:[htmlText dataUsingEncoding:NSUnicodeStringEncoding] options:@&#123; NSDocumentTypeDocumentAttribute: NSHTMLTextDocumentType&#125; documentAttributes:nil error:nil];self.myLabel.attributedText = mutableAttributeStr; NSDocumentTypeDocumentAttribute属性值:NSHTMLTextDocumentType 就是专门用来显示htmltext样式的 这样标签效果就能生效了 而不会把标签显示出来了。但是我又想在不影响html标签里样式的同时设置标签外的字体大小为17, 我们需要使用它的另一个枚举属性方法-(void)enumerateAttribute:(NSString )attrName inRange:(NSRange)enumerationRange options:(NSAttributedStringEnumerationOptions)opts usingBlock:(void (^)(id __nullable value, NSRange range, BOOL stop))block NS_AVAILABLE(10_6, 4_0); 123456789NSRange range = (NSRange)&#123;0, mutableAttributeStr.length&#125;; [mutableAttributeStr enumerateAttribute:NSFontAttributeName inRange:range options:NSAttributedStringEnumerationLongestEffectiveRangeNotRequired usingBlock:^(id _Nullable value, NSRange range, BOOL * _Nonnull stop) &#123; UIFont* currentFont = value; UIFont *replacementFont = nil; if ([currentFont.fontName rangeOfString:@&quot;bold&quot; options:NSCaseInsensitiveSearch].location == NSNotFound) &#123; replacementFont = [UIFont systemFontOfSize:17.0f]; [mutableAttributeStr addAttribute:NSFontAttributeName value:replacementFont range:range]; &#125; &#125;]; 因为标签样式都有加粗效果,那么在它的fontName中都带有bold字符(打印fontName依次为:TimesNewRomanPS-BoldMT，TimesNewRomanPSMT，TimesNewRomanPS-BoldMT，TimesNewRomanPSMT), 所以我们过滤一下没有加粗的部分 并设置为17号字体, 最终标签外的first 和 blog 就变成17号字体啦!","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://leonzlw.github.io/tags/iOS/"}]},{"title":"开启博客之旅","slug":"myBlog","date":"2016-03-21T10:03:07.000Z","updated":"2018-02-05T19:29:41.000Z","comments":true,"path":"2016/03/21/myBlog/","link":"","permalink":"http://leonzlw.github.io/2016/03/21/myBlog/","excerpt":"年前就开始着手搭建个人博客,无奈中途项目开工一直忙到了现在,再整理的时候发现遗忘的差不多了,只能重新来过,虽然有点曲折,但总算是完工了,还是值得开心纪念一下,哈哈!创建博客的初衷是想整理一些在项目中遇到的实际问题和对自己一段时间的技术总结。 加油!做一只有梦想的Coding Dog!","text":"年前就开始着手搭建个人博客,无奈中途项目开工一直忙到了现在,再整理的时候发现遗忘的差不多了,只能重新来过,虽然有点曲折,但总算是完工了,还是值得开心纪念一下,哈哈!创建博客的初衷是想整理一些在项目中遇到的实际问题和对自己一段时间的技术总结。 加油!做一只有梦想的Coding Dog!","categories":[],"tags":[{"name":"出发","slug":"出发","permalink":"http://leonzlw.github.io/tags/出发/"}]}],"categories":[{"name":"分类测试","slug":"分类测试","permalink":"http://leonzlw.github.io/categories/分类测试/"},{"name":"分类测试2","slug":"分类测试/分类测试2","permalink":"http://leonzlw.github.io/categories/分类测试/分类测试2/"}],"tags":[{"name":"出发222","slug":"出发222","permalink":"http://leonzlw.github.io/tags/出发222/"},{"name":"再出发","slug":"再出发","permalink":"http://leonzlw.github.io/tags/再出发/"},{"name":"iOS","slug":"iOS","permalink":"http://leonzlw.github.io/tags/iOS/"},{"name":"出发","slug":"出发","permalink":"http://leonzlw.github.io/tags/出发/"}]}